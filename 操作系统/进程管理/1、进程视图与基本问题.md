# 概念与视图

概念

* 进程用来描述一个程序及其执行过程中的信息，即描述一个执行中的程序，所以才将其命名为进程，即进行中的程序。
* 进程是管理 CPU 引出的概念，而 CPU 管理又是计算机管理的核心，所以进程这个概念的理解对于理解整个操作系统而言是最重要的。



再具体化一些

* 进程描述的是“程序以及**反映程序执行信息的数据结构的总和**”，因此这个数据结构就成为认识进程的一个关键。
* 人们给这个数据结构定义了一个基本概念，即进程控制块（Process Control Block，简写为 PCB）



多进程图像

* CPU的工作原理就是取出指令 执行指令，实际上就是执行程序，而执行起来的程序是进程，因此**使用 CPU 就是启动一个进程**
* CPU 管理的最终结构可以概括为：**要高效管理 CPU，需要启动多个进程，并能多个进程之间调度、切换。**





多进程图像是操作系统的核心图像

* 操作系统从开机启动到最后关机的全部运行过程中，都要围绕这个多进程图像进程工作。

* 具体的说，在系统启动的最后，进程 0 被“创造”了出来；然后通过 fork() 系统调用创建出了 1 号进程，并让 1 号进程执行 shell 程序；接下来 shell 会 fork() 一个进程来执行用户敲入命令对应的程序；用户程序可以使用 fork() 再产生出的进程来执行相应的任务。

  * 一个进程执行完毕以后可以调用 exit 来退出自己，但 shell 不会调用 exit 退出自己，除非关机。因此 shell 进程会一直执行，一直为我们创建出新的进程，并用这些新进程为我们完成各种各样的事情，这就形成了用户眼里的多进程图像。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121001006509.png)





# 进程基本问题

## 组织与状态

管理 PCB

* 操作系统管理进程的关键就是管理进程对应的 PCB 数据结构，所以组织多个进程就是用合适的数据结构来管理这些 PCB。
* 实际上，进程之间的关系并不复杂，通常都是并列的“排在”各自的队列里等待 CPU 空闲、等待磁盘读写完成等等
* 因此这些 PCB 之间的关系就是一种线性关系，简单而高效的一种方式就是将这些 PCB 组织成队列。
  * 但在进程管理时需要区分进程到底位于哪个队列，因为等待 CPU 的进程和等待磁盘读写完成的进程是不一样的
  * 等待 CPU 的那些进程在当前进程（正在执行的那个进程称为当前进程）让出 CPU 的时候，都可以获得 CPU 向前执行；而对于等待磁盘读写完成的进程，即使当前进程让出了 CPU，这些进程也不能来执行，因为还有等待条件没有满足。



进程状态

* 运行态 当前占有 CPU 正在执行的进程状态；

* 就绪态 一个进程具备了所有可以执行的条件，只要获得 CPU 就能开始执行；

* 阻塞态 一个进程因为缺少某些条件，即使分配了 CPU 也无法执行的状态。

* 即，有了这三个状态，就相应的产生了三个 PCB 队列：运行队列；就绪队列和阻塞队列。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121001027906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70)



进程生命周期

* 利用进程状态还可以描述一个进程在其执行过程中的演化过程，这个过程通常也称为进程的生命周期

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121001046673.png)


* 可以用日志来记录这个全图，如下面给出的进程日志片段

  ```
  进程ID  状态  时刻
    1     N    48
    1     J    49
    0     J    49
    1     R    49
    2     N    49
    2     J    49
  ```

* 通过这个日志，我们还可以统计出进程的执行情况，比如统计每个进程从新建到退出的时间间隔等，从而可以对整个操作系统进行量化分析，比如分析 CPU 利用率（统计的就是时间片的使用情况，因为每次 schedule 时都有就绪态）等。





## 切换与调度

什么时候切换

* 当 CPU 出现空闲的时候就引起切换。
* CPU 什么时候空闲呢？这可以有多种情况
  * 当前进程执行了需要 CPU 等待的指令 CPU 就会空闲，如启动磁盘读写等；
  * 当前进程执行了 exit() 退出时 CPU 也会空闲，等等。



调度点

* 空闲点通常也被称为调度点（所以那个完成切换的函数名字为 schedule）。

* 调度点可以是当前进程在执行过程中产生的，如 exit()，也可以是操作系统硬性加入的，如给每个进程分配一个时间片（前面讨论过的分时系统），当前进程的时间片用完时，操作系统会硬性的加入一个调度点进行切换。



如何实现切换

* 简言之，调用操作系统给我们提供的函数 schedule()。

* 这个函数的实现原理很简单

  * 即从就绪队列中选择出下一个进程的 PCB，对应下面代码中函数 getNext() 返回 pNew，可以最简单的返回就绪队列中的第一个进程。
  * 然后用 PCB 结构 pNew 中存放的执行现场
  * 切换之前还应该将 CPU 里面的“当前进程执行现场”保存在 pCur 结构中。

* 伪代码

  ```c
  某个进程 
  {
      启动磁盘写;
      
      pCur.state = ‘W’（修改进程状态）;
      将 pCur 放到 DiskWaitQueue;
      
      schedule()（引起切换）;
  }
  
  schedule()
  {
      pNew = getNext(ReadyQueue);
      switch_to(pCur,pNew);
  }
      
  switch_to(pCur,pNew)
  {
      pCur.ax = CPU.ax;
      pCur.bx = CPU.bx;
      ······
      pCur.cs = CPU.cs;
      pCur.ip = CPU.ip;
      CPU.ax = pNew.ax;
      CPU.bx = pNew.bx;
      ······
      CPU.cs = pNew.cs;
      CPU.ip = pNew.ip;
  }
  ```

* 切换原理看起来很简单，但在实际操作系统实现中，却非常复杂

  

选择下一个进程的困难

* 实际操作系统中总是同时存在各种各样的进程，虽然每次选择就绪队列首部的进程作为下一个进程是一个绝对公平的方案，但是有些进程应该优先执行，比如工作在前台的网页浏览器进程，而不是保证公平。
* 另一个方面，如果工作在前台的进程总是优先，那么工作在后台的进程，如编译整个操作系统的 make 进程就可能总是得不到执行，这也不合适。
* 如何合理折中这些多种多样的进程是一项重要又困难的任务。



## 影响分离

内存相互影响

* 多个进程同时在内存中交替执行可以提高 CPU 使用效率，但也会产生一些问题，因为都在内存中的多个进程会互相影响。

* 比如：进程 1 在执行过程中执行了一条修改内存地址 100 的指令，而地址 100 处存放的却是进程 2 的数据，导致的结果显然是进程 2 会发生错误崩溃。



解决办法：地址隔离

* 基本想法：每个进程操作的地址不直接是真实的物理内存地址
  * 进程 1 并不能通过代码中的这个地址来直接操作物理内存地址 100 的地方，而是通过一个映射表对应到一个真实物理地址
* 由于操作系统给每个进程分配一段只属于该进程的、互相不重叠的内存区域，当然内存共享除外。
  * 所以即使进程 2 也要在程序中访问地址 100 但通过映射表访问到的实际物理内存地址是 1100。
  * 此时两个进程的地址空间就能被完全分离开来，每个进程可以随意读写任何地址，不用担心会误操作会影响到别的进程，也不用担心别的进程会影响到自己，因为操作系统已经通过映射表将两个进程的地址空间隔离开了。





## 合作与通信

合作

* 多个进程同时放在内存中，需要隔离相互之间的影响，但有时也要相互合作（例如剪切板）
* 基本的进程间合作模型是一个进程要往一个缓存区写数据，而另外一个进程要从缓存区里读数据。此时就需要一个合适的进程间通信机制与合作机制。



通信方法

* 方法有很多，例如读写同一个数据库、读写同一个文件、读写一段共享内存、读写一段内核态内存等都是进程间通信的手段，实现起来并不困难。
* 真正困难的部分是要提供合适的进程间合作机制，如果没有这样的合作机制，就会出现很多奇怪的错误（并发问题）
  * 例如，一个进程往缓存区中写数据，另一个进程从缓冲区中读取数据，如果缓存区已经被写满了，但那个写进程仍然还在不断地往里写，那么就会导致信息的丢失



临界区问题

* 定义一个 counter 即可解决 生产消费问题
* counter 的加减如何保证原子，即 读取 、加/减、写回 三个操作的原子
