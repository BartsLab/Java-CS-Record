# 虚拟内存

* 原因：程序用户想要分段，物理内存想要分页



采用一个中间结构将段、页结合在一起

* 将程序分成多个段，并从中间结构上分割出一些区和每个段建立映射，完成分段机制；
  * 将中间结构分割成页，将这些页放到物理内存的页框中，并建立这个页和页框的映射，完成分页机制。
* 中间结构是一个看起来和物理内存一样，但没有对应物理存储单元的**虚拟内存**，正是虚拟内存这个关键概念（抽象）将分段机制和分页机制有机地结合在一起。



构建虚拟内存的核心步骤

* 在虚拟内存中分段、建立段表、虚存页映射到空闲物理页框、建立页表
* 说明：段表和页表都是全局的，因为页表是对应的任何虚拟地址



## Linux 0.11 实现

* 从进程创建的 fork() 开始



接着进程管理时论述的 copy_process 函数（在 sys_fork 中调用）

* 进程管理要利用这个函数完成进程 PCB 的创建、完成内核栈的分配与初始化、完成内核栈和 PCB 之间的关联等。

* 现在，内存管理要在这个函数中给进程建立地址空间：

  ```c
  int copy_process(int nr, long ebp,···)
  {
      ······
      copy_mem(nr, p);
  ```

  

copy_mem(nr, p)：建立 LDT，分配段基值

* 经过 GDT/LDT 后得到的**虚拟地址必须全局唯一**（即分配的虚拟地址个数可以大于物理内存，因为可以换入换出，所以说如果执行机器码，遇到代码或者数据没在内存中，那么 MMU 触发缺页中断就可以了，然后会根据触发缺页的虚拟地址，去把缺的东西加载到内存。如果是换出到磁盘了，那么就换入；如果是开始时就没载入，那么会从文件的 FCB 中找到 f_pos，然后读入接下来的磁盘块）

```c
int copy_mem(int nr, task_struct *p)
{
    // ...
    
    unsigned long new_data_base;
    // “new_data_base =nr*0x4000000”就是给出新建进程分割出来的虚存空间。0 号进程的 nr = 0，1号进程的 nr = 1，依次类推，
    // 每个进程都分割了 64M 虚存空间，且任意两个进程之间虚存地址空间没有重叠
    // 因为是被 fork 出来的进程是进程 2 ，所以当前 nr = 2
    new_data_base=nr*0x4000000; //64M*nr
    // p是下图要被 fork 出的进程 2 ，功能就是向进程 LDT 中写内容，因此就是建立段表
    set_base(p->ldt[1],new_data_base);
    set_base(p->ldt[2],new_data_base);
    
    // ...
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121004256429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70)



 copy_mem：

* 拿到父进程的页目录项和页表（通过段起始的虚拟地址），然后给子进程创建页目录项和页表

```c
int copy_mem(int nr, task_struct *p)
{
    // ...
    
    unsigned long old_data_base;
    // 得到父进程的虚存空间
    old_data_base=get_base(current->ldt[2]);
    // 将父进程内存页框的映射关系，拷贝给子进程的虚存空间 new_data_base。
    copy_page_tables(old_data_base,new_data_base,data_limit);
    
    // ...
```



copy_page_tables

* 根据虚拟地址构建页目录和二级页表

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121004314744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70)


  * 构建页目录（页目录的每项没有结构，通过虚拟地址高10位找到对应目录项后，里面就是二级页表的地址）

  * 构建二级页表（表项结构如下，高 20 位是物理页号）

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210121004331925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70)


```c
// from：发起 fork 的代码所在段的虚拟地址的起始地址
// to：将被 fork 出来的进程的段的虚拟地址的起始地址（在上面 copy_mem 完成的初始化）
int copy_page_tables(unsigned long from,unsigned long to, long size)
{
    // 虚拟地址 from 向右移动 22 位得到的就是页目录号，由于页目录表中的每个页目录项长度都是 4个字节，
    // 所以页目录号再乘以 4 就是页目录项在页目录表中的位置
    /**
     * 页目录项在页目录表中的位置再加上页目录表的起始地址就是页目录项所在的内存地址，
     * 由于页目录表被初始化放置在内存的 0 地址处（系统初始化 head.s 中有初始化页目录表的代码），
     * 所以从地址 ((from≫20)&0xffc) 处取出来内容就是父进程虚拟内存对应的页目录项中存放的内容（即页表地址）。
     */
    from_dir = (unsigned long *)((from≫20)&0xffc);
    // 被 fork 创建出来进程的页目录项地址
    to_dir = (unsigned long *)((to≫20)&0xffc);
    
    
    /**
     * 将父进程每个页目录项对应的页表里的所有页表项，拷贝到子进程页目录项对应的页表里
     * 由于每个进程的 64M 虚拟内存包含多个页目录项（即多张页表），实际上不难算出，每个页目录项（即一张页表）
     * 可以表示 1024×4K（因为虚拟地址里页表的索引就 10 位，所以页表最多 1024 项，而且一个内存页作为页表也就最多容纳 1024
     * 项），即 4M 大小的地址区域，64M 虚拟内存包含 16 个页目录项，所以才有这个 for 循环。
     * 
     * 而且还因为 +64M 后改变的是虚拟地址的高 10 位（第 25~31位），所以只改变了页目录的索引，并没有改变页表的索引和段内偏移
     */
    for(; size-- >0; from_dir++, to_dir++)
    {
        // 父进程页目录项指向的 1024 个页表项的起始地址（即低 12 位为 0 ，留个虚拟地址后 12 位作为页内偏移）
        from_page_table = (0xfffff000 & *from_dir);
        // 给子进程分配一个新的内存页来存放子进程对应的 1024 个页表项
        /**
         * get_free_page() 是在 mem_map数组中找到一个内容为 0 的项，并返回该项对应的物理地址即可。
         * 这个返回值应该是物理页号左移完 12 位（一个页面大小 4k）后的物理地址
         */
        to_page_table = get_free_page();
        // 子进程页目录项和页表的关联（把刚分配的空白页作为页表，将其地址送进页目录项里）
        *to_dir=((unsigned long)to_page_table)|7;
        
        // 用来完成页表项内容的复制
        for(;nr-- >0;from_page_table++,to_page_table++)
        {
            // 具体的表项
            this_page = *from_page_table;
            // 设置为只读，因为如果父子进程都可以写，那么两个进程在并发执行时就会互相影响而导致错误。
            // this_page &= 2 将页表项的倒数第 2 位设置为 0，用来表示这一页只读。
            // 如果要写的话会触发异常的中断，然后操作系统会给分配一个新的物理页
            this_page &= 2; 
            
            // 将父进程的页表项填到子进程的页表中
            *to_page_table = this_page;
            *from_page_table = this_page;
            
            this_page -= LOW_MEM;
            // 拿到物理页号（因为页表项的高 20 位是物理页号）
            this_page »= 12;
            // 把 mem_map 的该物理页 + 1（表示不空闲）
            // 也防止在父子进程中的一个进程释放内存时将这个物理页框释放掉。
            mem_map[this_page]++;
        }
    }
}
```



fork 后的示例： 父进程都执行 *p = 7，子进程执行 printf(\*p)，子进程执行 *p = 8

* 父进程：
  * 假定编译以后 p 的逻辑地址是 0x300。为计算出物理地址，MMU 首先找到数据段基址，即从当前进程的 LDT[2] 中找到基地址，是 0x04000000（因为是 1 号进程，所以起始地址是 64M 处），从而算出虚拟地址是 0x04000300。
  * 接下来需要根据虚拟地址查找页表得到物理地址，根据页表该虚拟页对应的物理页框号是 3，所以物理地址是 0x3300（物理页号左移 12 位，然后加上虚拟地址最低 12 位）。
  * MMU 会将 0x3300发到地址总线上，CPU 会将 7 发到数据总线上，结果是内存 0x3300 处的单元上内容会变成为 7，这就是 *p = 7 的执行结果。
* 子进程  printf(\*p)
  * 父子进程使用同样的代码，所以子进程中的 p 也是 0x300。执行这条指令时，也要进行地址翻译：从子进程的 LDT[2] 中取出基地址 0x08000000（因为是 2 号进程，所以起始地址是 128M 处），虚拟地址是 0x08000300。
  * 接下来再查找页表，由于复制了父进程的页表项（即用 21~12 位查找页表项是相同的，物理页内偏移也是相同的），所以物理页框号仍然是 3，物理地址还是 0x3300，MMU 会将 0x3300 发到地址总线上，所以会打印父进程写入的 7

* 子进程 *p = 8
  * 现在子进程执行语句 *p = 8，此时逻辑地址 0x300 经过地址翻译以后得到的物理地址仍然是 0x3300，现在要往 3 号物理页框中写内容。fork() 时将这个页框设置为只读，现在要写，因此会出现内存**读写异常的中断**，中断处理的结果是新分配一个页给出子进程，这就是著名的**写时复制**。
  * 操作系统会为虚存空间 0x08000000 处的第一个虚拟页新申请一个物理页框（调用get_free_page() 获得一个空闲物理页），此处是申请了 7 号物理页框，再修改页表完成 0x08000000 处第一个虚拟页和 7 号物理页框的映射。重新执行指令 *p = 8，再次地址翻译以后得到的物理地址是 0x7300，MMU 会将 0x7300 发到地址总线上，CPU 会将 8 发到数据总线上，结果是物理内存 0x7300 处的内容变为 8。
