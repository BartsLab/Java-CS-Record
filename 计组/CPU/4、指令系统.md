# 机器指令

**指令的一般格式**

<img src="https://img-blog.csdnimg.cn/20201219134520242.png" width="30%" height="50%" />

* 操作码（反映机器做什么操作）

  * 长度固定
    * 用于指令字长较长的情况  ，RISC
    * 如 IBM 370  操作码 8 位
  * 长度可变

* 操作码分散在指令字的不同字段中

* 扩展操作码技术

  * 操作码的位数随地址数的减少而增加

    <img src="https://img-blog.csdnimg.cn/20201219134542237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70" width="50%" height="50%"  />

  * 预留拓展

    * 三地址指令操作码每减少一种最多可多构成 $2^4$  种二地址指令
    * 二地址指令操作码每减少一种最多可多构成$2^4$ 种一地址指令

* 地址码

  * 四地址

    <img src="https://img-blog.csdnimg.cn/20201219134604193.png" width="20%" height="50%"  />

    * 设指令字长为 32  位、操作码固定为 8  位
    * 4 次访存，寻址范围 $2^6$ = 64

  * 三地址
  
    <img src="https://img-blog.csdnimg.cn/20201219134622899.png" width="20%" height="50%" />

    * 4  次访存，寻址范围 $2^8$ = 256

  * 二地址

    <img src="https://img-blog.csdnimg.cn/20201219134644930.png" width="20%" height="50%" />

    * 4  次访存，寻址范围 $2^{12}$ = 4k

  * 一地址

    <img src="https://img-blog.csdnimg.cn/20201219134706133.png" width="20%" height="50%"  />

    * 2  次访存，寻址范围 $2^{24}$ = 16M

  

  

**指令字长**

  * 决定于
    * 操作码的长度
    * 操作数地址的长度
    * 操作数地址的个数
  * 指令字长  固定
    * 指令字长 =  存储字长
  * 指令字长  可变
    * 按字节的倍数变化

  

**小结**

* 当用一些硬件资源代替指令字中的地址码字段后

  * 可扩大指令的寻址范围
  * 可缩短指令字长
  * 可减少访存次数

* 当指令的地址字段为寄存器时

  * 格式
    * 三地址 OP R 1 , R 2 , R 3
    * 二地址 OP R 1 , R 2 
    * 一地址 OP R 1
  * 可缩短指令字长
  * 指令执行阶段不访存

  

# 操作数类型和操作类型

**操作数类型**

* 地址：无符号整数
* 数字：定点数、浮点数、十进制数
* 字符：ASCII
* 逻辑数：逻辑运算



**数据在存储器中的存放方式**

* 从任意位置开始存储

  <img src="https://img-blog.csdnimg.cn/20201219134728503.png" width="50%" height="50%"  />

  * 优点：不浪费存储资源
  * 缺点：除了访问一个字节之外，访问其它任何类型的数据，都可能花费两个存储周期的时间。读写控制比较复杂。

* 从一个存储字的起始位置开始访问

  <img src="https://img-blog.csdnimg.cn/20201219134752406.png" width="50%" height="50%" />

  * 优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。
  * 缺点：浪费了宝贵的存储资源

* 边界对准方式——从地址的整数倍位置开始访问

  <img src="https://img-blog.csdnimg.cn/20201219134819979.png" width="50%" height="50%" " />

  * 数据 存放的起始地址是数据 长度（按照编址单位进行计算）的整数倍
  * 本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重



**操作类型**

* 数据传送

  <img src="https://img-blog.csdnimg.cn/20201219134841597.png" width="50%" height="50%"  />

* 算术逻辑操作

  <img src="https://img-blog.csdnimg.cn/20201219134916624.png" width="50%" height="50%"/>

* 移位操作

  <img src="https://img-blog.csdnimg.cn/20201219134939358.png" width="30%" height="50%"  />

* 转移

  * 无条件转移 JMP
  * 条件转移
    * 结果为零转 （Z = 1） ） JZ
    * 结果溢出转 （O = 1 ）JO
    * 结果有进位转（C = 1 ）JC
    * 跳过一条指令 SKP

  * 调用和返回
    * CALL
    * RETURN
  * 陷阱（Trap）与陷阱指令
    * 一般不提供给用户直接使用，在出现事故时，由 CPU 自动产生并执行（隐指令）
    * 设置供用户使用的陷阱指令（如 8086 INT TYPE 软中断提供给用户使用的陷阱指令，完成系统调用）

* 输入输出

  * 入: 端口 中 的内容  -> CPU  的寄存器（IN 指令）
  * 出 CPU  的寄存器 -> 端口 中的内容（OUT 指令）

 # RISC & CISC  

**RISC 主要特征**

* 选用使用频度较高的一些  简单指令，复杂指令的功能由简单指令来组合
* 指令  长度固定、指令格式种类少、寻址方式少
* 只有 LOAD / STORE  指令访存
* CPU  中有 多个通用  寄存器
* 采用  流水技术 一个时钟周期  内完成一条指令
* 采用  组合逻辑 



**CISC  的主要特征**

* 系统指令  复杂庞大 ，各种指令使用频度相差大
* 指令  长度不固定、指令格式种类多、寻址方式多
* 访存  指令  不受限制

* CPU  中设有专用寄存器
* 大多数指令需要多个时钟周期执行完毕
* 采用微程序 



**RISC 和 CISC**

* RISC 更能  充分利用 VLSI  芯片 的面积
* RISC  更能  提高计算机运算速度

  * 指令数、指令格式、寻址方式少，
  * 通用  寄存器多 ，采用  组合逻辑  ，
  * 便于实现  指令流水
* RISC  便于设计 ，可降低成本 ，提高可靠性
* RISC  不易实现 

