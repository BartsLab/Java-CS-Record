### 同步实现

* 核心就是硬件提供原子操作指令



#### 基本硬件原语

在多处理机中实现同步，所需的主要功能是：

* 一组能以**原子操作**的方式读出并修改存储单元的硬件原语。
  * 它们都能以原子操作的方式 读+修改 存储单元
  * 并指出所进行的操作是否以原子的方式进行。
* 通常情况下，用户不直接使用基本的硬件原语，原语主要提供程序员编制同步函数库



典型操作

* 原子交换
  * 功能：将一个存储单元的值和一个寄存器的值进行交换。
    * 建立一个锁，锁值：
      * 0 ： 表示开的（可用）
      * 1 ： 表示已上锁（不可用）
  * 处理器上锁时，将对应于该锁的存储单元的值与存放在某个寄存器中的1进行交换。
    * 存储单元的值此时已置换为1，防止了别的进程竞争该锁。
  * 实现同步的关键：操作的原子性
* 测试并置定（test_and_set）
  * 先测试一个存储单元的值，如果符合条件则修改其值。
* 读取并加1（fetch_and_increment）
  * 它返回存储单元的自增值
* 使用指令对
  * LL (load linked 或 load locked) 的取指令
  * SC (store conditional) 的特殊存指令



LL/SC 指令顺序执行：

* 如果由 LL 指明的存储单元的内容在 SC 对其进行写之前，已被其它指令改写过，则第二条指令 SC 执行失败；

  * 如果在两条指令间进行切换也会导致 SC 执行失败。
  * 这对指令的核心是 SC 写的时候检查完 cache 行的状态，如果不命中不是发 wtMiss，而是返回 0

* 步骤

  * LL 返回该存储单元初始值。
  * SC 将返回一个值来指出该指令操作是否成功：
    * “ 1” ： 成功
    * “ 0” ： 不成功

* 还可以用来构造别的同步原语

  * 原子交换操作

    ```
    try ： OR R3, R4, R0       // R4 中为交换值。把该值送入 R3
    	   LL R2, 0 （ R1 ）    //  把单元0（ R1 ）中的值取到 R2
    	   SC R3, 0 （ R1 ）    //  若0（ R1 ）中的值与 R3 中的值相同，则置 R3 的值为1 ，否则置为0
    	   BEQZ R3, try        //  存失败（ R3 的值为0）则转移
    	   MOV R4, R2          //  将取的值送往
    ```

    

  * 例如：构造原子操作 fetch_and_increment

    ```
    try： LL R2, 0 （R1）
    	 DADDIU R2, R2, #1
    	 SC R2, 0 （R1）
    	 BEQZ R2, try
    ```





#### 旋转锁

概念

* 处理器环绕一个锁不停地旋转而请求获得该锁。
* 适合于这样的场合：锁被占用的时间很少，在获得锁后加锁过程延迟很小。





核心：Cache的一致性

* 将锁调入Cache，并通过一致性机制使锁值保持一致。

* 优点：

  * 可使“环绕”的进程只对本地 Cache 中的锁（副本）进行操作，而不用在每次请求占用锁时都进行一次全局的存储器访问；
  * 可利用访问锁时所具有的局部性，即处理器最近使用过的锁不久又会使用。（减少为获得锁而花费的时间）

* 实现（利用 LL/SC 实现）

  ```
  lockit ： LL R2, 0 （ R1 ）
  		 BNEZ R2,  lockit
  		 DADDIU  R2, R0, #1
  		 SC R2, 0 （ R1 ）
  		 BEQZ R2, 
  ```

* 3 个处理器利用原子交换争用旋转锁所进行的操作

  <img src="https://img-blog.csdnimg.cn/20201225164549193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70" width="50%" />





#### 同步性能

原因

* 简单旋转锁不能很好地适应可缩扩性。大规模多处理机中，若所有的处理器都同时争用同一个锁，则会导致大量的争用和通信开销。



栅栏同步

* 栅栏强制所有到达该栅栏的进程进行等待，直到全部的进程到达栅栏，然后释放全部的进程，从而形成同步。



典型实现（用两个旋转锁）

* 用来保护一个计数器，它记录已到达该栅栏的进程数；
* 用来封锁进程直至最后一个进程到达该栅栏。
  * 实际上也不叫旋转锁，即已经到达的进程会不断检查一个标志，只有当该标志变成 1 才继续进行，而该标志由最后一个到达的进程更改。
* 实现
  * lock 和 unlock 提供基本的旋转锁
  * 变量 count 记录已到达栅栏的进程数
  * total 规定了要到达栅栏的进程总数

```
lock （counterlock ）；    // 确保更新操作原子性
if （count==0） 
	release=0 ；   // 第一个进程则重置 release
count=count+1 ；   // 到达进程数加1 1
unlock （ counterlock ）；  // 释放锁

if（count==total ）{  // 进程全部到达
	count=0 ；   // 重置计数器
	release=1 ； // 释放进程
｝
else { // 还有进程未到达
	spin （ release=1 ）； // 等待别的进程到达（即只有 relase = 1 的时候，才会继续前进）
｝
```


