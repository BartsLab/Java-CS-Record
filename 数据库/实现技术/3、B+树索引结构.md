#### 实现：B+树索引

**多级索引**

* 当索引项比较多时，可以对索引再建立索引，依此类推，形成多级索引。

	<img src="https://img-blog.csdnimg.cn/20201127095016318.png?" width="50%" height="50%" />


**B+树索引：一种以树型数据结构来组织索引项的多级索引**

* 结构：<img src="https://img-blog.csdnimg.cn/20201127095112832.png" width="50%" height="50%" />
  * Ki—索引字段值
  * Pj—指针，指向索引块或数据块或数据块中记录的指针
  * 一个节点就是一个索引块，包含有n-1个索引项(<索引字段值Ki, 指针Pi>)+1个指针(Pn);
    * 示例：存储块= 4096 Byte，整数型索引 字段值= 4 Byte、 指针= 8 Byte
    * 则：n应满足4(n-1)+8n<=4096 ，即 n取最大值n=341

  

* 结构：
	<img src="https://img-blog.csdnimg.cn/20201127095242315.png?" width="50%" height="50%" />

  * 每个索引块的指针利用率都在50%-100%之间

    * 一索引块实际使用的索引指针个数d，满足(根结点除外)：n/2 <= d <= n，不然就会进行合并或分裂

    

  * 叶结点和非叶节点的指针指向

    * 非叶结点指针指向索引块

      
	<img src="https://img-blog.csdnimg.cn/20201127095334327.png?" width="50%" height="50%" />

    * 叶结点指针指向主文件的数据块或数据记录

      
	<img src="https://img-blog.csdnimg.cn/20201127095406390.png" width="50%" height="50%" />
	
    

  * 索引字段值重复出现于叶结点和非叶结点

    * 所有非叶节点合起来最多只会出现一次叶子结点的索引值

    * 指向主文件的指针仅出现于叶结点，所有叶结点即可覆盖所有键值的索引；

    * 索引字段值在叶结点中是按顺序排列的；

      

    
	<img src="https://img-blog.csdnimg.cn/20201127095438118.png?" width="50%" height="50%" />





**B+树建立不同的索引**

针对不同 DBMS 要考虑聚簇索引是不是建立在主键上，所以就有四种情况（主键决定该属性是否重复，聚簇索引决定主文件是否按该属性组织）

* 建立键属性稀疏索引(或主索引)（有序 + 无重复）

  * 索引字段是主文件的主键，索引是稀疏的。主文件必须按主键排序。
  * 指针指向的是**数据块**，即同一个数据块只被该索引文件指向一次

  
	<img src="https://img-blog.csdnimg.cn/20201127095517447.png?" width="50%" height="50%" />


* 建立非键属性稠密索引（有序 + 有重复）

  * 索引字段是主文件的非键属性，索引是稠密的。主文件按非键属性排序
  * 索引文件的索引字段是无重复的。指针指向所有记录不同值其所在的第一个数据块。

  
	<img src="https://img-blog.csdnimg.cn/20201127095552776.png" width="50%" height="50%" />



* 建立键属性稠密索引（无序 + 无重复）

  * 索引字段是主文件的主键，索引是稠密的。主文件可以按主键排序，也可以不按主键排序。
  * 指针会指向每条所在的数据块，即使这个数据块已经被指向过了。

 
	<img src="https://img-blog.csdnimg.cn/20201127095628862.png" width="50%" height="50%" />



* 非键属性稠密索引（无序 + 有重复）

  * 索引字段是主文件的非键属性，索引是稠密的。主文件不按非键属性排序
  * 索引文件的索引字段是有重复的，会给每条记录都指向所在的数据块。

  
	<img src="https://img-blog.csdnimg.cn/20201127095656374.png" width="50%" height="50%" />

  



​    

**B Tree  vs. B+ Tree**

<img src="https://img-blog.csdnimg.cn/20201127095725408.png?" width="70%" height="70%" />

* 索引字段值都出现在哪里？指向主文件的指针存在哪里？一块中存放的索引项个数是否相同？

  * B+树只能叶子节点的指针指向主文件，B树的每个节点都存放指向主文件的指针
* 对于同一大小的索引块而言，如果都能放满的话，那么B+ 树的索引项个数多于 B树，因为 B+ 树的非叶索引块不放行指针
  * 也正是 B+ 树只有叶子节点放数据，所以查询更平衡

* 分裂与合并的方法是否一致？

  * 基本一致，但也有不同，增加都会分裂，但是删除多了合并
  * B+ 树的叶子节点间有指针，通过这个指针来保证所有的指针利用率都在50%-100%之间，因为每个节点的指针利用率是由下向上决定的，所以只要保证了最底层叶子节点的空间利用率就可以保证上层节点的空间利用率。
    * 在删除时，如果叶子节点里索引项个数少于百分之50，那么会和相邻的节点合并或者窃取索引项
    * 同时叶子节点的双向指针还可以方便的范围检索






**B+树键值插入与结点分裂**

在下列B+树中插入键值为40的记录

<img src="https://img-blog.csdnimg.cn/20201127095818844.png" width="50%" height="50%" />

* (1)、寻找保存键值记录的叶子结点

  (2)、应插入结点已满，则申请新结点

  (3)、对于应插入但未插入结点，使其均衡存放于两个叶结点中(分裂)，然后讲要插入的节点放到分裂后节点的正确位置

  (4)、调整叶子节点水平方向指针，使其指向新叶子结点

 
	<img src="https://img-blog.csdnimg.cn/20201127095847535.png?" width="50%" height="50%" />

* (5)、寻找指向新叶子结点的父级非叶结点，让操作的节点变为找到的父节点

  (6)、向节点插入另外一个分裂得到叶子节点的首元素

  (7)、若应插入结点已满，则申请新结点，使其均衡存放于两个叶结点中(分裂)，然后讲要插入的节点放到分裂后节点的正确位置

  (8)、调整节点的竖直方向，即子结点指针，使其指向正确

  重复 (5) - (8)，直至当前非叶节点不用分裂

	<img src="https://img-blog.csdnimg.cn/20201127095917376.png" width="50%" height="50%" />

* 最终状态

  

	<img src="https://img-blog.csdnimg.cn/20201127095948661.png?" width="50%" height="50%" />

  	

* 总结：实际上就是若子节点分裂，那么先调整水平方向指针，让后上溢分裂得到的右半边节点的首元素，父节点也按照这个规则，如果分裂了就上溢分裂后的右半边节点的首元素，直到不再分裂为止

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2020112713320383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)






**键值删除与结点合并过程示意**

在下列B+树中删除键值为7的记录（窃取）

<img src="https://img-blog.csdnimg.cn/20201127100029263.png" width="50%" height="50%" />

* (1)、叶子结点中寻找等于键值的记录，删除相应的指针及主文件中对应的记录

  (2)、调整其左侧(或右侧)结点及本结点中的键值记录, 使其均衡存放于两个叶结点中

 
	<img src="https://img-blog.csdnimg.cn/20201127133010158.png?" width="50%" height="50%" />
* (3)、如有调整，则进一步调整其上层非叶结点，重新确定其键值，以满足大于等于键值的记录都在其右侧

  <img src="https://img-blog.csdnimg.cn/20201127133106926.png" width="50%" height="50%" />



在下列B+树中删除键值为11的记录（合并）


<img src="https://img-blog.csdnimg.cn/20201127133223535.png" width="50%" height="50%" />

* (1)、叶子结点中寻找等于键值的记录，删除相应的指针及主文件中对应的记录

  (2)、将本结点的剩余键值, 移动到左侧(或右侧)结点。此空结点将被删除。调整叶结点指针

 
	<img src="https://img-blog.csdnimg.cn/20201127133300767.png?" width="50%" height="50%" />

* 如有调整，则进一步调整其上层非叶结点，重新确定其键值，以满足大于等于键值的记录都在其右侧

	<img src="https://img-blog.csdnimg.cn/20201127133341122.png" width="50%" height="50%" />
 	
	<img src="https://img-blog.csdnimg.cn/20201127133415799.png" width="50%" height="50%" />



* 总结：实际上删除就是两种合并方法，一种是把当前节点和相邻节点合并，然后调整合并后节点的父节点的指针，另一种是从相邻节点窃取一个元素，然后调整当前节点或相邻节点中，头部元素改变的父节点指针

 
	<img src="https://img-blog.csdnimg.cn/20201127133445587.png" width="60%" />
