### 关系模型

#### 概述

形象地说，一个关系(relation) 就是一个Table，关系模型就是处理Table 的，它由三个部分组成：

* 描述DB 各种数据的基本结构形式(Table/Relation)
* 描述Table 与Table 之间所可能发生的各种操作( 关系运算)
* 描述这些操作所应遵循的约束条件(完整性约束)



关系模型的三个要素

* 基本结构 ：Relation/Table
* 基本操作 ：Relation Operator
  * 基本的： $\bigcup$ ( 并, UNION)、  $-$ ( 差, DIFFERENCE) 、 $\times$ ( 广义积,PRODUCT)、   $\sigma$( 选择, SELECTION)、   $\prod$ ( 投影, PROJECTION) 。
  * 扩展的： $\bigcap$ ( 交, INTERSECTION) 、 $\Join$ ( 连接, JOIN)、$\div$ ( 除, DIVISION)  运算
* 完整性约束： 
  * 实体完整性 
  * 参照完整性 
  * 用户自定义的完整性



关系运算

* 关系代数：基于集合的运算（即操作的对象及结果都是集合，是一次一集合的操作；而非关系型的数据操作通常是一次一记录的操作）。
* 关系演算：元组演算（基于逻辑的运算，操作对象为每条元组）、域演算（基于逻辑的运算，操作对象为选定域组成的元组）



#### 什么是关系

首先定义“ 列” 的取值范围“：域(Domain)

* 域(Domain)：一组值的集合，这组值具有相同的数据类型



再定义“元组”及所有可能组合成的元组个数

* 笛卡尔积
  * 笛卡尔积(Cartesian Product)：一组域D1, D2,..., Dn的笛卡尔积为:D1×D2×...×Dn= { (d1, d2, ... , dn) | di∈Di, i=1,...,n }
  * 笛卡尔积的每个元素(d1, d2, ... , dn) 称作一个n-元组（n-tuple）

* 元组

  * 元组(d1, d2, ... , dn)的每一个值di叫做一个分量(component)
  * 元组(d1, d2, ... , dn)是从每一个域任取一个值所形成的一种组合，笛卡尔积是所有这种可能组合的集合，即：笛卡尔积是由n个域形成的所有可能的n-元组的集合

  * 若Di的基数为mi，则笛卡尔积的基数，即元组个数为m1×m2×...×m



关系定义

* 一组域D1, D2,..., Dn的笛卡尔积的子集
* 笛卡尔积中具有某一方面意义的那些元组被称作一个关系(Relation)，因为要有意义，所以要给每一列起个属性名，只有该元组的所有分量对应的属性都有意义，那么该元组才能称为关系。





关系模式定义（即为什么把“表”说为关系）

* 关系可用R(A1:D1, A2:D2, ... , An:Dn)表示，可简记为R(A1, A2, ... , An)，这种描述又被称为关系模式(Schema)或表标题(head)
* R是关系的名字, Ai是属性, Di是属性所对应的域, n是关系的度或目(degree), 关系中元组的数目称为关系的基数(Cardinality)
* 说明：关系模式R(A1:D1, A2:D2, ... , An:Dn)中属性向域的映象在很多DBMS中一般直接说明为属性的类型、长度等





关系模式与关系

* 同一关系模式下，可有很多的关系
* 关系模式是关系的结构, 关系是关系模式在某一时刻的数据
* 关系模式是稳定的；而关系是某一时刻的值，是随时间可能变化的



#### 特性

列是同质

* 即每一列中的分量来自同一域，是同一类型的数据

* 不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。

* 关系模式R(A1:D1, A2:D2, ... , An:Dn)中，Ai (i = 1,...,n)必须是不同的, 而Di(i = 1,...,n) 可以是相同的



列位置互换性：区分哪一列是靠列名

行位置互换性：区分哪一行是靠某一或某几列的值(关键字/键字/码字)

* 关系是以内容(名字或值)来区分的，而不是属性在关系的位置来区分



理论上，关系的任意两个元组不能完全相同。(集合的要求：集合内不能有相同的两个元素)；现实应用中，表(Table)可能并不完全遵守此特性。

元组相同是指两个元组的每个分量都相同





#### 概念

候选码(Candidate Key)/候选键

* 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。



主码(Primary Key)/主键

* 当有多个候选码时，可以选定一个作为主码。
* DBMS以主码为主要线索管理关系中的各个元组。



主属性与非主属性

* 包含在任何一个候选码中的属性被称作主属性，而其他属性被称作非主属性
* 最简单的，候选码只包含一个属性
* 最极端的，所有属性构成这个关系的候选码，称为全码(All-Key)。



外码(Foreign Key)/外键

* 关系R中的一个属性组，它不是R的候选码，但它**与另一个关系S的候选码相对应**（因为要满足连接的无损性，不产生，则称这个属性组为R的外码或外键。
* 两个关系通常是靠外码连接起来的。



#### 完整性

实体完整性

* 关系的主码中的属性值不能为空值；
* 空值：不知道或无意义的值；
* 意义：关系中的元组对应到现实世界相互之间可区分的一个个个体，这些个体是通过主码来唯一标识的；若主码为空，则出现不可标识的个体，这是不容许的



参照完整性

* 如果关系R1的外码Fk与关系R2的主码Pk相对应，则R1中的每一个元组的Fk值或者等于R2 中某个元组的Pk值，或者为空值
* 意义：如果关系R1的某个元组t1参照了关系R2的某个元组t2，则t2必须存在



用户自定义完整性

* 用户针对具体的应用环境定义的完整性约束条件
* 如S#要求是10位整数，其中前四位为年度，当前年度与他们的差必须在4以内



DBMS对关系完整性的支持

* 实体完整性和参照完整性由DBMS系统自动支持
* 用户自定义完整性通过用户自定触发器实现。

