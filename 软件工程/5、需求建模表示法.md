# 需求建模表示法

## 实体-联系图

*entity-relationship diagram，ER diagram*

3个核心结构：**实体、属性和联系**

实体*entity*：矩形，代表具有共同性质和行为的现实世界对象构成的集合（有时也称为类）

联系*relationship*：表示为两个实体之间的边，边的中间有一个菱形，说明联系的类型

属性*attribute*：是实体上的注释，描述实体相关的数据或性质

## UML 类图

统一建模语言是用于文档化软件规格说明和设计的一组表示法

每一个方框是一个**类**，表示一组相似类型的实体。一个类具有**名称（name）**、**属性（attribute）** 集和类的属性上的**操作（operation）** 集

属性是简单数据变量（即它的值太简单，本身不足以成为一个类），其值可以随着时间和类实体的不同而发生变化

**类范围属性（class-scope attribute）** 用带下划线的属性表示，是被类的所有实例共享的数据值

**类范围操作（class-scope operation）** 书写为带下划线的操作，是由抽象类执行的操作，而不是由类的实例执行的操作

两个类之间的连线称为**关联**，表示类的实体之间的关系

**聚合关联（aggregate association）** ：`has-a`关系，用空心菱形的关联来表示

**组装（composition）** 关联是一种特殊类型的聚合，用实心菱形的聚合来表示

一端带有三角形的关联表示**概化（generalization）** 关联，也称为子类型或`is-a`关系

**关联类（association class）**，将属性和操作联系到关联上

## 事件踪迹

*event trace*

事件踪迹是关于现实世界实体之间交换的事件序列的图形描述

每一条竖线表示不同实体的时间线，其名字出现在线的顶部。每一条水平线表示两个实体之间的一个事件或交互，通常理解为从一个实体到另一个实体的消息传递。时间按从顶到下踪迹进展。每一个图描述一个**踪迹（trace）**，表示的是若干可能行为中的一个

## 消息时序图

*Message Sequence Chart*

是扩充的事件踪迹表示法。具有创建和撤销实体、指定动作和计时器，以及组合事件踪迹的能力；一般只用于描述关键的场景，而不是说明整个问题。

每一条竖线表示一个参与的**实体**，而将一个**消息**描述为从发送实体到接收实体的箭头，箭头上的标记制定该消息的名称和数据参数。一个消息箭头可以向下斜，体现了消息发送时间和消息接受时间之间的时间段。虚线的箭头表示创建事件，产生新的实体。实体线底部的交叉符号表示实体执行的终结。**动作（action）** 为位于实体执行线上的带标记的矩形。**条件（condition）** 带标记的六边形。

## 状态机

*state machine*

用于在单个模型中表示一组事件踪迹，是一种图形描述，描述了系统与其环境之间的所有对话。每一个节点称为**状态**，表示存在于事件发生之间的一个稳定的条件集合。每一个边称为**转移（transition）**，表示由一个事件的发生而产生的行为或条件的变化。每一个转移都标记有触发事件，还可能有输出事件

## UML 状态图

用于描述一个UML类中对象的动态行为。根据涉及的实体与实体之间的关系，刻画出了一个问题的静态的、总体的视图。**没有说明实体是如何运转的，或对于输入事件，行为是如何变化的。** 而是说明的是，**一个类的实例**应该如何改变其状态，以及在这些对象彼此交互时，它们的属性值是如何改变的，即单个实体是如何响应输入事件以及产生输出事件的。

通常与MSC（消息时序图）【两个实体之间的消息传递】相辅相成。

具有**公共转移**的状态合并进**超状态（superstate）**，可以将超状态看作是子状态机，具有自己的状态和转移集。

------

转移标记的语法：`event(args) [condition] \ action* ^Object.event(args)*`

**触发事件**是一个可能携带参数的消息；**激活条件**由方括弧括起来，是关于对象属性的谓词。如果一个转移发生，其动作（每一个的前面带有斜杠`"/"`）表示对象属性的赋值；星号`"*"`表明一个转移可能含有任意多个**动作**。如果该转移发生，它可能生成多个**输出事件**，表示为`/^对象.事件`(`/^Object.event`)。一个输出事件可能携带参数，或者指定目标对象，或者广播到所有对象。

可以没有触发事件、条件等，表示总是被激活的

------

**动作&活动：**

动作是一个相对没有时间花费的计算，并且是不可中断的；活动是更为重要复杂的计算，它执行一段时间，并且可以被中断。

## Petri图

是**状态-转移表示法**的一种形式，用于建模并发活动以及它们之间的交互；Petri网中的圆圈称为**位置**，表示活动或条件；条表示**变迁**；有向的箭头称为弧，将变迁与其输入位置和输出位置连接在一起。位置中放置的是令牌（token），作为变迁的启动条件。当一个变迁被触发时，就清楚每一个输入位置中的令牌，并将令牌插入每一个输出位置。为每一条弧分配一个权重，指出在变迁触发的时候，在弧的输入位置清除了多少令牌，或者在弧的输出位置插入了多少令牌。

## 数据流图

*data-flow diagram，DFD*

建模功能以及从一个功能到另一个功能的数据流；一个泡泡表示一个**加工（process）**或功能，它转换数据。箭头表示**数据流（data flow）**。单个计算使用之外的持久数据保存在**数据存储（data store）**，它是一个正式的库或信息库，表示为两个平行的条。数据源或数据接收器表示为矩形，称为**参与者（actor）**

优势：提供了两种直观的模型：一种是关于被提议系统的高层功能的，一种是各种加工之间的数据依赖关系。

最好作为问题的早期模型使用，因为此时细节并不是很重要。

## UML用例图

*use-case diagram*

类似于顶层的数据流图，它根据系统和系统的环境之间的交互，描述可观察到的、用户发起的功能。大的方框表示系统的边界；方框外的小人描绘的是参与者，包括人或系统；方框之内的椭圆是用例，表示**必需的主要功能及其变种**；参与者和用例之间的线表明参与者参与了该用例。用例不一定建模系统应该提供的所有任务，而是用于说明用户对重要系统行为的观察。

虚线箭头，标注构造型`<<include>>`或者`<extend>`，分别表示调用和扩展

## 函数与关系

基于数学的规格说明和设计技术称为**形式化方法**

当一个输入值映射到多个输出值的时候，就使用**关系**

每一个输入都映射到单个输出，则这个函数定义上是**一致的**；如果一个函数为每一个不同的输入指定一个输出，则称为全函数，并且定义上是**完备的**。

## 判定表

*decision table*

是函数规格说明的表格式表示，将事件和条件映射到适当的反应或动作上。

该规格说明是非形式化的，因为输入（事件和条件）和输出（动作）可以用自然语言表示，也可以用数学表达式表示，或者同时使用两者。

如果有n个输入条件，就可能会有2n个条件的组合。

## Parnas表

是数学函数和关系的表格式表示；与判定表不同的是，Parnas表的输入和输出是纯数学表达式。

## 逻辑

**描述性的表示法**是，根据问题或提议的解决方案的性质或者不变行为来对它进行描述的表示法，更适合于表达全局性质或约束

**逻辑**由一种表述性质的语言加上一组推理规则组成，这些推理规则用于规定的性质导出新的、合乎逻辑的性质。

## 对象约束语言

*Object control language*

具有数学精确性，又对非数学专业人员易读、易写、易理解的约束语言

（感觉像是类似于数据库的E-R图+类图）

## Z

发音为*zed*

**形式化**的需求规格说明语言，将**集合论**的变量定义组织到一个问题的完整的抽象数据类型模型当中，并使用逻辑来表示每一个操作的前置条件和后置条件。

Z利用软件工程的抽象方法将规格说明分解为可管理的模块，称为**模式（schema）**

## SDL数据

SDL数据用于创建**规格说明和描述语言（SDL）** 中的用户定义数据类型以及参数化的数据类型

操作：生成操作（构建定义数据类型的规范表示）、操纵操作（返回值）、查询
