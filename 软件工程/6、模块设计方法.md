# 设计模块

## 设计方法

1. 使用自顶向下或者由外向内的方法，以关注系统的输入和期望的输出
2. 首先探究设计中最难最不明确的一部分，因为隐蔽问题所引发的异常可能会迫使整个设计做出改变
3. 按垂直切片的方式推进开发过程，每次都迭代地设计和完成各个功能子集（敏捷开发中）
4. 使用自底向上的方法，尝试使用和调整已有的方案去解决该部分的设计

**重构：** 为了简化过度复杂的方案，或者出于某特殊性能的考虑而对设计进行优化，会周期性地重审和修改设计决策

## 设计原则

**设计原则：** 把系统功能和行为分解成模块的指导方针

六个主要的原则：

- 模块化/关注点分离

  - 耦合度
    - 当两个模块之间有大量依赖关系时，则说这两个模块是**紧密耦合的**
    - **松散耦合的** 模块之间具有某种程度的依赖性，但是它们之间的相互连接比较弱
    - **非耦合的** 模块之间没有任何相互连接，它们之间是完全独立的
    - 耦合类型：（越后面耦合程度越低）
      - 内容耦合：被修改的模块完全依赖于修改它的模块
      - 公共耦合：对公共数据的改变意味着需要通过反向跟踪所有访问过该数据的模块来评估该改变的影响
      - 控制耦合：某个模块通过传递参数或返回代码来控制另一个模块的活动
      - 标记耦合：使用一个复杂的数据结构来从一个模块到另一个模块传送消息，并且传递的是该数据结构本身
      - 数据耦合：传送的只是数据值，而不是结构数据时【理想的】
      - 非耦合
  - 内聚度：模块的内部元素的”粘合”程度（越后面内聚程度越高）
    - 巧合内聚：模块的各个部分互不相关
    - 逻辑内聚：模块的各个部分只通过代码的逻辑结构相关联
    - 时态内聚：设计被划分为几个用来表示不同执行状态的模块
    - 过程内聚：组合在一起只是为了确保执行顺序
    - 通信内聚：围绕数据集构造的模块
    - 功能内聚：在一个模块中包含了所有必需的元素，并且每一个处理元素对于执行单个功能来说都是必需的（某个功能内聚的模块不仅执行设计的功能，而且只执行该功能，不执行其他功能）【理想的】
    - 信息内聚：在功能内聚的基础上，将其调整为数据抽象化和基于对象的设计

- 接口：为系统其余部分定义了该软件单元提供的服务，以及如何获取这些服务

  - 一个对象的接口是该对象所有公共操作以及这些操作的**签名**的集合，指定了*操作名称、参数和可能的返回值*

  - 软件单元接口的

    规格说明

    描述了软件单元外部可见的性质

    - 目标：为每个访问函数的功能性建立充分详细的文档，以帮助其他开发人员找出最符合他们需要的访问函数
    - 前置条件：所有的假设，以帮助其他开发人员了解在何种情况下，该软件单元才能正确工作
    - 协议：协议的信息包括访问函数的顺序、两个构件交换消息的模式，比如，调用一个模块访问共享资源之前需要被授权允许
    - 后置条件：可见的影响，为其编写文档，包括返回值、引发的异常以及公共变量的变化
    - 质量属性：是对开发人员和用户可见的质量属性

- 信息隐藏：目标是使得软件系统更加易于维护；单元的设计决策被隐藏了

- 增量式开发

  - 使用关系：为各个软件单元和它依赖的单元之间建立关联
  - 使用图：节点代表软件单元，有向边从使用其他单元的软件单元A出发指向被使用的单元B【表示需要一个正确的B，才能保证A也能正确地工作】良好的使用图应具有树型结构或者树型结构的森林
  - 扇入*fan-in*：使用某个软件单元的软件单元数量
  - 扇出*fan-out*：某个软件单元使用其他软件单元的数量
  - 最终目的是创建高扇入、低扇出的软件单元
  - 夹层法：消除循环，将循环中的一个单元被分解成两个单元
  - 依赖倒置*dependency inversion*

- 抽象：忽略一些细节来关注其他细节的模型或表示

- 通用性：在开发软件单元时，使它尽可能地能够成为通用的软件，来加强它在将来某个系统中能够被使用的可能性

  - 软件工程原则之一就是**可复用性**：构造在将来的软件产品中仍可使用的软件单元，旨在通过复用来**分摊**开发的成本（分摊*amortization*是指，在计算软件单元的成本时，考虑每次使用的成本，而不是开发项目时的整个成本）
  - 实现规则：
    - 将特定的上下文环境信息参数化
    - 去除前置条件
    - 简化后置条件

## 面向对象的设计

如果一个设计将系统分解成若干个封装了数据和函数的运行时构件，即所谓的对象，那么该设计是面向对象的*object oriented*

对象区别于其他构件的特征：

- 对象是唯一**可标识的**运行时实体，它们可以设计为消息或请求的目标
- 对象是**可组合的**，因为它的数据变量本身可能也是对象，因而封装了对象的内部变量的实现
- 对象的实现可以通过**继承**的方式被复用和扩展，用来定义其他对象的实现
- 面向对象的代码可以是**多态的**：可以对多个不同但类型相关的对象都起作用的通用代码。相关类型的对象会对一些相同消息或请求做出响应，但不同类型的对象会有不同的响应

对象的数据称作**属性**，而对象的操作称作**方法**；对象之间通过发送消息、调用彼此的方法进行交互。

对象是运行时实体；面向对象设计往往是由对象的**类**和**接口**构成的。接口声明了外部可访问的属性和方法。通常，这些信息是指公共方法，同时包含了这些方法的签名、前置条件、后置条件、协议要求以及可见的质量属性

若一个接口所提供的服务是另一个接口所提供的服务的严格子集，那么我们称前者是后者的**子类型**，**后者称为前者的超类型**

------

**抽象类** **动态绑定** **对象组合** **继承**

类继承和对象组合之间的选择是一种涉及设计一致性、行为可预测性、设计决策的封装性、运行时性能和运行时可配置性的权衡

组合方法在保持被复用的封装性方面优于继承，因为组合的对象仅能通过它声明的接口来访问构件

组合的最大优点，在于它允许动态替换对象构件；缺点：很难仅通过研究代码，就能够想清楚或推理出程序的运行时结构，也并不能搞清楚一个对象到底引用了哪些对象，同时对象的引入了一层间接性，一个构件的方法的每一访问都必须先访问这个构件对象，可能会影响到程序运行时的性能

继承最大的好处就是，通过选择性地覆盖被继承的定义，可以改变和特化继承方法的行为，可以帮助我们快速创建具有新行为的、新的类型的对象。

------

**可替换性：** 但是不是强制的，在很多设计中，不能满足

依赖父类的客户端代码在传送一个子类实例时，可能不能正常工作。

**利斯科夫替换原则** *Liskov Substitutability Principle*描述了一下原则：（根据该原则，当同时满足以下条件时，一个子类对于其父类就是可替换的）

1. 子类支持父类的所有方法，并且他们的签名是兼容的。即子类的方法的参数和返回类型对于父类方法的对应的参数和返回类型，是可替代的。

2. 子类的方法必须满足父类方法的规格说明。即这两个类的方法行为不一定要完全相同，但是子类必须不违反父类方法的前置条件以及后置条件
   $pre_{\text{parent}} = pre_{\text{sub}} $

   子类的前置条件必须和父类的前置条件相同或弱于父类的前置条件

   $pre_{\text{parent}}\to (Post_{\text{sub}}\to Post_{\text{parent}})$
   子类方法所做的和父类一样多，甚至比父类的还多

3. 子类必须保留父类中声明了的所有性质

------

组合可能会导致类之间形成大量的依赖关系

**德米特法则** *law of Demeter*（不要和陌生人说话）:通过把组合类中作用在类构件上的每个方法都包含进来，可以降低他们的依赖程度

比如：

- generateBill()方法调用CustomerAccount中的printSaleItems();
- printSaleItems()调用合适的Sale对象中的printItemList()
- printItemList()调用合适的Item对象中的打印方法

往往会使用**包装类** *wrapper class*，以在不改变现有类的实现的前提下增加新功能。

尽管包装类使得向组合类中增加操作的任务变得轻松了，但同时也会使得设计更加复杂以及降低运行时的性能。

因此，在决定是否遵循德米特法则的时候，要在设计复杂度、开发时间、运行时性能、防止故障和易维护性之间进行权衡。

------

**依赖倒置：** 消除类形成的依赖循环

客户端依赖于服务器

将依赖类（客户端）增加接口，然后打包成一个新的模块；再将被依赖类（服务器类）创建包装类，将两者连接起来；这样当服务器类改变接口时，不会影响客户端

------

4种面向对象的结构（类、对象、 接口和实例变量）以及结构之间的关系，用箭头指示，箭头的末端的注释表明了关系的**多重性**（有时也称为”**元数**”）（几对几的关系）

## 在UML中体现面向对象设计

UML图包括了系统的动态视图、静态视图、约束和形式化

动态视图：

- 用例图

  use case diagram

  - 通过描述系统必须执行的一般过程对系统进行描述
  - 活动图、领域模型对其进行补充
  - 展示系统必要的功能，以及与系统交互的主要**参与者** *actor*

- 活动列表

- 表示顺序和通信的交互图

- 表明状态及其变化的状态机

静态视图：

- 类图
  - 用来表示关系【关联、泛化、依赖和实现】和可扩展性【约束、标记值和构造性】）
  - 关系类型
    - 直线 关联
    - 组合 黑菱形
    - 聚合 白菱形
    - 泛化 空心三角形
    - 依赖 虚线 实心三角形
    - 导航 实心三角形
- 包图
  - 虚线表示包的依赖关系
- 部署图
  - 如何为构件分配计算资源

约束和形式化：

- 对象约束语言（OCL）

模块设计首先从类图开始；接下来，将对系统的动态方面进行设计，交互图：顺序图（垂直线表示该对象的生命线）和通信图、活动图、状态图；最后将这些类打包，使得设计更加层次化、更便于理解。最终的模型是包图。

可以首先提取名词，寻找可以作为类的元素。

## 面向对象设计模式

## 面向对象的度量

**系统规模：**

1. COCOMO
2. 专化指数 **SI=（NOO\*深度） / 类的方法的总数**

NOO：子类覆载override的操作数目

**设计质量：**

1. 每个类的加权
2. LCOM

## 其他

1. 数据管理
2. 异常处理：用来消除易检查的前置条件的最有效的方法
3. 用户界面设计
4. 框架：设计复用

## 设计文档

**按合同设计**

接口规格说明：

- 需要
- 前置条件
- 协议
- 提供
- 后置条件
- 协议
- 质量属性
