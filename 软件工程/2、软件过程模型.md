# 软件过程
在软件开发中所遵循的路线图称为 **“软件过程”**。
* 过程是活动的集合，活动是任务的集合。

软件过程有3层含义：
* 个体含义（软件产品或系统在生存周期中的某一类活动的集合）
* 整体含义（软件产品或系统在所有上述含义下的软件过程的总体）
* 工程含义（解决软件过程的工程）


------

过程包含以下7种类型的要素：

1. 活动
2. 序列：活动的顺序
3. 过程模型：是关于系统兴趣的观点
4. 资源
5. 控制
6. 策略：指导原则
7. 组织：过程代理的层次化结构

------

过程：
* 一组有序的任务，它涉及**活动、约束、资源**使用的一系列步骤
* 软件开发过程有时又称为**软件生命周期**

包含以下活动：

- 需求分析与定义
- 系统设计
- 程序设计
- 编写程序
- 单元测试
- 集成测试
- 系统测试
- 系统交付
- 维护

------

开发团队人员：

- 需求分析员
- 设计人员
- 程序员
- 测试人员
- 培训人员

一般来说，维护过程中，开发团队的所有人员都需要参与

* **资料管理人员**负责准备和存储在系统生命周期中用到的文档，包括需求规格说明、设计描述、程序文档、培训手册、测试数据、进度等。

* **配置管理小组**，让开发人员知道若改变需求，需要改变哪些，会影响哪些；还要协调可能建立或支持的系统的不同版本


# 评价模型

## CMM（Capability Maturity Model of Software）

* **软件过程能力成熟度模型**，提供了一种评价软件承接方能力的方法，同时它可帮助软件组织改进软件过程。

五个成熟度级别：
* 1、初始级
* 2、可重复级
	* 建立**基本的项目管理过程和实践**来跟踪项目费用、进度和功能特性
	* 有必要的**过程准则**来**重复**以前在同类项目中的**成功**

* 3、已定义级
	* 管理和工程两方面的软件工程已经**文档化、标准化**，并综合成整个软件开发组织的标准软件过程。
	* 所有项目都采用**根据实际情况修改后**得到的**标准软件工程**来开发和维护软件。

* 4、已管理级
	* 制定了软件过程和产品质量的**详细度量标准**。
	* 软件过程的产品质量都被开发组织的成员所理解和控制

* 5、优化级
	* 加强了**定量分析**，通过来自**过程质量反馈**和来自**新观念、新技术的反馈**使过程能**不断持续地改进**

### CMMI 两种表示方法

**能力成熟度模型**
* 是若干过程模型的综合和改进，是支持多个工程学科和领域的、系统的、一致的过程改进框架
* 能适应现代工程的特点和需要，能提高过程的质量和工作效率。

1、阶段式模型
* 类似于CMM，关注**组织的**成熟度
1. 初始的：过程不可预测且缺乏控制
2. 可重复的：过程为项目服务
3. 已定义的：过程为组织服务
4. 定量管理的：过程已度量和控制
5. 优化的：集中于过程改进

2、连续式模型
* 关注于每个**过程域的**能力
* 能力等级：

   - CL0（未完成的）
   - CL1（已执行的）
   - CL2（已管理的）
   - CL3（已定义级的）
   - CL4（定量管理的）
   - CL5（优化的）

# UP 统一过程

**统一过程模型**
* 一种”**用例和风险驱动**，**以架构为中心**，**迭代并且增量**“的开发过程
* 由UML方法和工具支持。


迭代指的是
* 将整个软件开发项目划分成许多个小的”袖珍项目”
* 每个”袖珍项目”都包含正常软件项目的所有元素：计划、分析与设计、构造、集成和测试，以及内部和外部发布。


典型代表：**RUP（Rational unified Process）**。
* RUP是UP的商业扩展，兼容UP，但比UP更完整、更详细

### 4个技术阶段及其制品：
1、起始阶段
* 专注于项目的**初创**活动
* **工作产品：**
	* 构想文档、初始用例模型、初始项目术语表、初始业务用例、初始风险评估、项目计划（阶段及迭代）、业务模型以及一个或多个原型（需要时）
* **里程碑：** 
	* 生命周期目标

2、精化阶段
* 在理解了最初的领域范围之后进行**需求分析**和**架构演进**
* **工作产品：**
	* 用例模型、补充需求（包括非功能需求）、分析模型、软件体系结构描述、可执行的软件体系结构原型、修订的风险列表、项目计划（包括迭代计划、调整的工作流、里程碑和技术工作产品）以及初始用户手册
* **里程碑：**
	* 	生命周期架构

3、构建阶段
* 关注系统的**构建**，产生**实现模型**
* **工作产品：**
	* 设计模型、软件构件、集成的软件增量、测试计划及步骤、测试用例以及支持文档（用户手册、安装手册和对于并发增量的描述）
* **里程碑：**
	* 初始运作功能

4、移交阶段
* 关注于**软件提交方面**的工作，产生**软件增量**
* **工作产品：**
	* 提交的软件增量、β测试报告和综合用户反馈
* **里程碑：**
	* 产品发布

# 软件过程模型
也称为软件开发模型，它是软件开发全部过程、活动和任务的结构框架。
* **静态模型**描述过程，表明了从输入到输出的转换过程
* **动态模型**能够动态展现过程，这样用户能够看到中间产品和最终产品是如何随着时间的推移进行转换的

------

过程模型中，方框表示活动，从左边进入的箭头表示资源，从右边离开的箭头表示输出，从顶部进入的箭头表示控制或约束，从下部进入的箭头表示机制（这些机制辅助开发人员执行活动，例如：工具、数据库或技术）

------

**过程表示法：** 如何用执行过程的人员能够理解的方式记录过程

**过程模型：** 如何使用一组合适的活动、资源、产品和工具来描述过程

**过程建模支持工具：** 如何演示或模拟一个过程模型，从而可以评价资源的可用性、有用性和性能

**过程测度和评价：** 在特定的时间或环境下，如何判断哪些活动、资源、子过程和模型类型最有益于生产高质量产品

------

## 瀑布模型 Waterfall Model

瀑布模型
* 将软件生存周期中的各个活动规定为依**线性顺序连接**的若干阶段的模型，包括*需求分析、设计、编码、测试、运行与维护*。
* 它规定了由前至后、相互衔接的**固定次序**，如同瀑布流水逐级下落。

以**文档**为驱动，适合于**软件需求很明确**的软件项目的模型

**优点：**

* 容**易理解**，**管理成本低**；
* 强调开发的阶段性早期计划及需求调查和产品测试

**不足：**

* 客户必须完整、正确、清晰地**表达**他们的**需要**；
* 在开始的两个或三个阶段中，很**难评估**真正的进度状态；
* 当**接近项目结束时**，出现了**大量的集成和测试**工作；
* 直到项目结束之前，都**不能演示系统的能力**；
* 对于项目风险的控制能力较弱


#### 变体：V模型

* V模型**左侧步骤向下推进**，基本问题需求**逐步细化**，形成问题及解决方案的技术描述。
* 一旦编码结束，沿着V模型**右侧的步骤向上推进**工作，其实际上是执行了一系列的**测试（质量保证活动）**

瀑布模型关注**文档和制品**，而V模型关注**活动和正确性**


## 阶段化开发
阶段化开发：
* 增量和迭代

通常会有两个系统在并行运行：产品系统和开发系统
* **运行系统**或**产品系统**是当前正在被客户和用户使用的系统；
* 而**开发系统**是准备用来替换现行产品系统的下一个版本

### 增量模型 Incremental Model

将需求分段成**一系列增量产品**，每一增量**分别开发**。
* 该模型采用随着日程时间的进展而**交错的线性序列**，每一线性序列产生软件的一个可发布的增量。
* 客户对每个增量的使用和评估都作为下一个增量发布的**新特征和功能**。


**优点：**（除具有瀑布模型的优点之外）

* 第一个可交付版本所需要的**成本和时间很少**；
* 开发由增量表示的小系统所承担的**风险不大**；
* 由于很快发布了第一个版本，因此可以**减少用户需求的变更**；
* 运行**增量投资**，即在项目开始可以仅对一个或两个增量投资。

**不足：**

* 如果没有对用户的变更要求规划，那么产生的初始增量可能会造成后来增量的不稳定；
* 如果需求不像早期思考的那样稳定和完整，那么一些增量需要重新开发，重新发布；
* 管理发生的成本、进度和配置的复杂性可能会超出组织的能力。

### 迭代模型

增量模型是**增加**功能，而迭代模型是在一开始就提交一个完整的系统，然后在每一个新的发布中**改变**每个子系统的功能。

## 演化模型 Evolutionary Model

演化模型是**迭代**的过程模型，特别适用于对**软件需求缺乏准确认识**的情况

### 原型模型 Prototype Model

**原型**是预期系统的一个可执行版本，反映了系统性质的一个选定的子集。
* 一个原型不必满足目标软件的所有约束，其目的是能**快速、低成本**地构建原型。

原型模型
* 开始于沟通，**其目的是定义软件的总体目标，标识需求**，然后快速制定原型开发的计划，确定原型的目标和范围，采用快速设计的方式对其进行建模，并构建原型。
* 被开发的原型应交付给客户使用，并收集客户的反馈意见，这些反馈意见在**下一轮**中对原型进行改进。（一轮完成后，下一轮才开始，和增量的交错线性不同）

根据原型的目的不同，原型可以分为：

- 探索型原型
	- 弄清**目标的要求**，确定所希望的特性，并探讨多种方案的可行性

- 实验型原型
	- **验证方案或算法的合理性**，是在大规模开发和实现前，用于考查方案是否合适、规格说明是否可靠

- 演化型原型
	- **将原型作为目标系统的一部分**，通过对原型的多次改进，逐步将原型演化成最终的目标系统

确认和验证
* 系统测试阶段会确认，**确认**（*validation*）确保系统实现了所有的需求；
* 也会对需求进行**验证**（*verification*），验证确保每一项功能都是正确的

### 螺旋模型 Spiral Model

螺旋模型将瀑布模型和原型模型合起来，加入了两种模型均忽略的**风险分析**
* 适用于**庞大、复杂且具有高风险**的系统

四个步骤：

1. 制定计划：决定目标、方案和限制
2. 风险分析：评价方案、识别风险、消除风险
3. 实施工程：开发、验证下一产品
4. 用户评估

**优点：**
* 支持**用户需求的动态变化**，为用户参与软件开发的所有关键决策提供了方便，有助于提高软件的适应能力
* 并且为项目管理人员及时调整管理决策提供了便利，从而降低了软件开发的风险。

**不足：**

* 开发人员需要具有丰富的风险评估经验和专门知识；
* 过多的迭代次数会增加开发成本，延迟提交时间。

### 喷泉模型 Water Fountain Model

喷泉模型是一种以**用户需求为动力**，以对象作为驱动的模型
* 适合于**面向对象的开发方法**；
* 开发过程具有迭代性和无间隙性（指在开发活动【如分析、设计、编码】之间不存在明显的边界）。
* 克服了瀑布模型不支持软件重用和多项开发活动集成的局限性

**优点：**
* 提高软件项目的开发效率，节省开发时间

**不足：**
* 需要大量开发人员，不利于项目的管理；
* 需要严格管理文档，使得审核难度加大

## 基于构件的开发模型 Component-based Development Model

利用**预先包装的构件**来构造应用系统。
* 构件可以是组织**内部开发**的构件，也可以是**商品化成品**（Commercial Off-The-Self，COTS）软件构件。
* 本质上是**演化模型**，需要以迭代方式构建构件。

包括**领域工程**和**应用系统工程**两部分

## 形式化方法模型 Formal Methods Model

建立在**严格数学基础上**的一种软件开发方法，其主要活动是生成**形式化的数学规格说明**

## 其它模型

### 可操作规格说明模型

**可操作规格说明模型**，通过演示系统行为的方式来评估或执行系统需求。
* 即，一旦指定了需求，就可以用软件包进行演示。

瀑布模型把功能与设计分离，而可操作规格说明模型允许把功能和设计合并起来

### 可转换模型

去除某些主要开发步骤来设法减少出错机会。
* 利用自动化手段的支持，转换过程使用一系列转换把需求规格说明变为一个可支付使用的系统。

转换的样例有：
- 改变数据表示
- 选择算法
- 优化
- 编译
