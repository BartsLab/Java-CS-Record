# 编写程序

编程应该具有**标准**，不仅方便自己的修改，查找故障，之后返回工作等等；同时也助于小组工作

每个程序构件都至少包括3个主要方面：

1. 控制结构
   通用化但又不影响其性能
   文件开头列出构件之间传递的参数信息
2. 算法
   执行时间与设计质量、标准和客户需求之间平衡考虑
   对于速度，需要了解编译器是如何优化代码的
3. 数据结构：通常是为了适合于整体方案：促进信息隐藏和对构件接口的控制
   保持程序简单

**通用性指导原则：**

1. 局部化输入输出
2. 包含伪代码
3. 改正和重写，而不是打补丁
4. 复用

## 文档

### 程序文档

解释程序做什么以及如何做的书面描述

### 内部文档

直接书写在代码中的描述性素材

**头注释块**：提供概要信息以识别程序，描述数据结构、算法和控制流；通常以一组注释的形式放在每个构件的开始部分

必须包含：

1. 构件名字
2. 谁编写了这个构件
3. 构件应该装配在整个系统设计的哪个地方
4. 构件是在何时编写和修改的
5. 为什么要有这个构件
6. 构件是如何使用数据结构、算法和控制的

**其他注释块：** 对代码的解释，增加的是新信息而不是从标记和变量名中显而易见的部分

**有意义的变量名和语句标记**

**安排格式以增强理解：** 例如缩进

**文档化数据**

### 外部文档

设计人员不看代码，就评审外部文档

从系统的角度回答：who, what, where, when, how and why

**描述问题：** 不是重复需求文档，而是对背景的概要讨论，解释什么时候调用构件以及为什么需要它

**描述算法**

**描述数据**

## 编程过程

- 将编程作为问题求解
- 极限编程
- 结对编程

# 测试程序

测试并不是发现故障的第一事件，需求和设计评审也会帮助我们在开发的早期检查出存在的问题

测试的重点是**发现故障**

## 软件故障和失效

软件失效，意味着该软件没有做需求描述的事情

失效是系统某些方面的一个或多个故障造成的

故障不一定会产生失效

可能的原因：

- 规格说明可能是错误的，或者遗漏了某个需求
- 对于指定的硬件和软件，规格说明可能包含不可能实现的需求
- 系统设计中可能包含故障
- 程序设计中可能包含故障
- 程序代码是错误

测试的目标是发现错误，*只有当发现了错误或者由于测试过程而使得失效发生，一个测试才被认为是成功的*

**故障识别** *fault identification*是确定由哪一个故障或哪些故障引起失效的过程

**故障改正** *fault correction*或**故障去除** *fault removal*则是修改系统使得故障得以去除的过程

故障的类型

1. 算法故障*Algorithmic fault*：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。这些故障有时仅通过通读程序（称为**桌上检查**）或者通过提交我们期望程序在其平常工作过程中接收的、来自于每一个不同类别数据的输入数据，就能很容易地找出来。

   典型的算法故障包括：

   - 分支太早
   - 分支太迟
   - 对错误的条件进行了测试
   - 忘记了初始化变量或忘记了设置循环不变量
   - 忘记针对特定的条件进行测试
   - 对不合适的数据类型变量进行比较

2. 语法故障*syntax fault*

3. 计算故障*computation fault*：一个公式的实现是错误的

4. 精度故障*precision fault*：计算结果没有达到要求的精度

5. 文档故障*documentation fault*：文档与程序实际做的事情不一致

6. 压力故障或过载故障：队列长度、缓冲区大小、表的维度等的限制

7. 能力故障或边界故障：系统活动到达指定的极限时，系统性能会变得不可接受

8. 计时故障或协调故障：几个同事执行的或按仔细定义的顺序执行的进程之间的协调问题

9. 吞吐量故障或性能故障：系统不能以需求规定的速度执行

10. 硬件和系统软件故障

11. 标准和过程故障

**恢复故障** *recovery fault*

如果被分类的任何一项都只属于多个类别，则分类方案是正交的

## 测试的组织

**模块测试**

**构件测试**

**单元测试**

**集成测试**：是验证系统构件是否能够按照系统和程序设计规格说明中描述的那样**共同**工作的过程

**功能测试**

**验收测试**

**安装测试**

**系统测试**

**忘我编程** *egoless programming*的态度，当发现一个故障或出现一次失效时，忘我开发团队关注的是修改故障，而不是谴责某个开发人员

**黑（闭）盒测试/白（开）盒测试**

## 单元测试

- 代码评审

   

  code review

   

  客观的是专家小组来评审代码及其文档

  - **代码走查** *code walkthrough* ：程序员向评审小组提交代码及其相关文档，然后评价它们的正确性，发现故障，不必修改它们
  - **代码审查** *code inspection*：正式点，事前准备好的关注问题清单来检查代码和文档

1. 形式化证明技术（用逻辑变量说明，画出流程图，证明定理以及程序可终止）
2. 符号执行，用符号代替变量执行
3. 自动定理证明

**测试**是**测试点/测试用例**的集合

- 语句测试：构件中的每条语句至少执行一次
- 分支测试
- 路径测试
- 定义使用的路径测试
- 所有使用的测试
- 所有谓词使用/部分计算使用的测试
- 所有计算使用/部分谓词使用的测试

**事务流测试**

## 集成测试

集成策略的选择不仅依赖于系统特性，而且依赖于客户的期望
无论选择什么样的策略，测试的每个构件都只合并一次。而且，绝不要为了简化测试而修改构件。桩和驱动程序是单独的、新的程序，而不是现有程序的临时修改

1. **自底向上集成**
   合并构件来测试较大型系统的流行方法
   每一个处于系统层次中最底层的构件首先被测试。接着要测试的是那些调用了前面已经测试构件的构件。反复地采用此方法，直到所有的构件都被测试完毕。
   当很多底层构件是常被其他构件调用的通用实用例程的时候，当设计是面向对象的时候，或者当系统及集成大量独立的复用构件的时候，自底向上的方法是很有用的。
   需要**构件驱动程序**，调用特定构件并向其传递测试用例的程序
   顶层构件是最重要的，却是最后测试的构件。顶层指导主要的系统活动，而底层通常执行更为普遍的任务。顶层更概括，而较低层次更为具体。主要故障的发现会推迟到测试的后期（有时顶层的故障反映的是设计中的故障）顶层构件通常控制或影响计时，当系统的大部分处理都依赖于计时的时候，就很难自底向上地测试系统
   对于**面向对象**的程序来说，自底向上的测试通常是最明智的选择。
2. **自顶向下集成**
   顶层构件，通常是一个控制构件，是独立测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复执行这种方法，直到所有的构件都被测试。
   正在测试的构件可能会调用还没有经过测试的别的构件，因此我们需要**编写一个桩** *stub*，这是一种专用程序，用于模拟缺少构件时的活动。但是编写桩比较困难，必须允许测试的所有可能的情况。并且测试中可能需要大量的桩
   **不需要驱动程序**
   修改以后：可以在合并之前单独测试构件，比如原来是(A) -> (A,B,C)；修改后是(A) -> (B) (C) -> (A,B,C)
3. **一次性集成**
   当所有构件都分别经过测试，再将它们合在一起作为最终系统进行测试，看看这个系统是否能一次运行成功
   同时需要桩和驱动程序；所有的构件是一次性地进行合并，很难发现引起失效的原因；很难将接口故障与其他故障区分开来
4. **三明治集成**
   将自底向上和自顶向下结合起来
   将系统看成三层：目标层在中间
   在顶层使用自顶向下的方法，而在较低层次使用自底向上方法
   修改：和2一样，在合并之前单独测试较上层的构件

## 测试面向对象系统

测试应该处理多个不同的层次：功能、类、聚集（协作对象的多组交互）和整个系统

和传统测试来说，在源代码分析、覆盖分析、测试用例生成、需求分析和验证方面不同

## 测试计划

测试计划：描述我们将以何种方式向客户证明软件运转正确（即软件没有故障并且执行需求中指定的功能）

不仅强调单元测试、集成测试，还包括系统测试
Who、Why、How、When

1. 制定测试目标
2. 设计测试用例
3. 编写测试用例
4. 测试测试用例
5. 执行测试
6. 评估测试结果

## 测试工具

### 代码分析工具

报告代码本身和正在运行的测试用例的相关信息

- 静态分析：在程序没有实际执行时使用的分析工具
  - 代码分析器：语法错误/概念易出现故障或者未定义；产生符号表
  - 结构检查器：将提交的构件作为输入，生成一张描述构件逻辑流的图。该工具检查结构方面的缺陷；确定循环的位置，标记永远不会执行的语句等
  - 数据分析器：检查数据结构、数据声明和构件接口，然后指出构件间不合适的链接、冲突的构件定义以及不合法的数据使用；当分母为零的时候，进行通知
  - 序列检查器：检查事件序列
- 动态分析：当程序运行时进行的，称为程序监控器（监视并报告程序的行为）

### 测试执行工具

- 获取和重放： 在测试运行时获取键击、输入和响应，并且将期望的输出与实际的输出进行比较
- 桩和驱动程序
- 自动化的测试环境

### 测试用例生成器

结构化测试用例生成器

## 停止测试

刚开始发现的错误多的话，说明之后的错误也很多；因此估算剩余故障是一个重要的环节

### 故障播种/错误播种

测试小组的一名成员在程序中有意地插入（播种）一定已知数目的故障，其他小组成员则尽可能多地查找故障

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210124224659232.png)


但是播种故障与程序中的实际故障难以保证时同种类型的而且复杂性相同；因此此方法，仅在以前构建过类似的系统时才有用。

通常情况下，我们会使用两个小组来查找，然后计算他们的有效性是多少，然后再计算出剩余的故障（有效性也要算进去）

### 可信度

通常用一个百分数表示，它说明软件无故障的可能性

直到发现了s个故障后

![c={1  n>NS(S−N+1)  n≤N](https://img-blog.csdnimg.cn/20210124224636152.png)


更改后，不用发现全部s个故障
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210124224631337.png)


这些估算假定所有故障被检测到的概率相同

### 其他标准

通过计算代码的覆盖值

### 识别出易出故障的代码

通过分析树进行判断
