### 垃圾回收判定与算法

#### 介绍

在 JVM 中,程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而灭，而栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的）。因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。



而 Java 堆和方法区这两个区域则有着很显著的不确定性，垃圾收集器所关注的正是这部分内存该如何管理。



#### 回收决定因素

##### 标记算法

###### 引用计数算法

无法解决循环引用

```java
public class ReferenceCountingGC {
	public Object instance = null;
    
	private static final int _1MB = 1024 * 1024;
	//这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
	private byte[] bigSize = new byte[2 * _1MB];
    
	public static void testGC() {
		ReferenceCountingGC objA = new ReferenceCountingGC();
		ReferenceCountingGC objB = new ReferenceCountingGC();
		objA.instance = objB;
		objB.instance = objA;
        
		objA = null;
		objB = null;
        
		// 假设在这行发生GC，objA和objB不能被回收
		System.gc();
	}
}
```



###### 可达性分析算法

基本思路

* 通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。



在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
* 所有被同步锁（synchronized关键字）持有的对象。
* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
* 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
* 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。



##### 引用类型

JDK 1.2 之前只有强引用，因此一个对象在这种定义下只有“被引用”或者“未被引用”两种状态，对于描述一些“食之无味，弃之可惜”的对象就显得无能为力。



强引用

* 是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj=new Object()”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

软引用

* 是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了 SoftReference 类来实现软引用。

弱引用

* 也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了 WeakReference 类来实现弱引用。

虚引用

* 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2版之后提供了 PhantomReference 类来实现虚引用。



##### finalize() 是否逃脱

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：

* 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
  * 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。
  * 这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。

* finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。



```java
public class FinalizeEscapeGC {
	public static FinalizeEscapeGC SAVE_HOOK = null;
    
	public void isAlive() {
		System.out.println("yes, i am still alive :)");
	}
    
	@Override
	protected void finalize() throws Throwable {
		super.finalize();
		System.out.println("finalize method executed!");
		FinalizeEscapeGC.SAVE_HOOK = this;
	}
    
	public static void main(String[] args) throws Throwable {
		SAVE_HOOK = new FinalizeEscapeGC();
		SAVE_HOOK = null;
        // 对象第一次成功拯救自己
		System.gc();
        
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
        
		// 下面这段代码与上面的完全相同，但是这次自救却失败了
        // 因为一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，其finalize()方法不会再次执行
		SAVE_HOOK = null;
		System.gc();
        
		// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它
		Thread.sleep(500);
		if (SAVE_HOOK != null) {
			SAVE_HOOK.isAlive();
		} else {
			System.out.println("no, i am dead :(");
		}
	}
}

// finalize method executed!
// yes, i am still alive :)
// no, i am dead :(
```












#### 垃圾收集理论算法

##### 分代收集理论

经验法则

* 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
* 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。 
* 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数
  * 即：分代后不应再为了少量的跨代引用去扫描整个老年代，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。



在Java堆划分出不同的区域之后

* 垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因而才有了“Minor GC”、“Major GC”、“Full GC” 这样的回收类型的划分
* 也才能够针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法，因而发展出了 “标记-复制算法”、“标记-清除算法”、“标记-整理算法” 等针对性的垃圾收集算法。



晋升并发安全（PLAB)

　　PLAB（Promotion Local Allocation Buffers），对象晋升到survivor分区或者老年代分区的过程是在GC线程的晋升本地分配缓冲区（PLAB）进行的，每个线程有独立的PLAB。作用是避免多线程竞争相同数据。和下面介绍的TLAB思想是一致的



分代的目的

* 分代有两个目的
  * 提高所能承受的对象分配速率，因为引入分代收集后，可以让新生对象都在一个专门的区域中创建，然后专门针对这个区域进行更频繁、更快的收集。
  * 还有一个目的，传统的收集器，如果只全堆回收（即 full gc），传统的 full gc 收集器都是标记-整理，那么必须长时间 stop the world（可能有人会说，可不可以跟 cms 一样，我先标记-清除，到一定程度再标记-整理，看似把老年代这种策略扩大到全堆是一个办法，但实际不可以，局部有内存碎片可以接受，但全堆都是内存碎片是无法忍受，可以想象成新生代都是内存碎片，那么势必也会频繁的触发标记-整理），所以解决策略就是分代，留出一个规整的新生代，并且让执行时间短的 young gc 先清理堆中掉绝大多数朝生夕灭的对象，还有 young gc 标记-复制的时候也要 stop the world 但为什么时间短可以频繁执行 ，因为新生代要存活的对象很少，那么要移动的对象也就很少，所以就快，但放眼全堆是并不具备这个条件的。
* 不分代也有两个目的（比如 ZGC）
  * 分代必须要解决跨代引用问题，那么势必会增加增加记忆集的内存消耗，与写屏障维护记忆集的系统负载。所以 ZGC 不用再维护记忆集，但每次回收都会扫描所有的Region，即用范围更大的扫描成本换取省去记忆集内存消耗与维护成本，这也是一种权衡。
  * 还有一个原因，ZGC 使用染色指针和内存多重隐射，可以在全堆 标记-整理 时，做到高性能的并发整理，只有极短的 stop the world。所以即使 ZGC 不分代，每次进行全堆扫描，在一段时间的运行环境里，总延时几倍的优于其他回收器，吞吐量也可以做到和 parallel 组合相当（要一段时间是由于，ZGC 虽然每次整堆回收，但回收频率肯定比分代收集器会下降，因为 ZGC 是全堆达到阈值才回收，但分代收集器会频繁 young gc）
* 所以还可以得出一个结论
  * 不是 Full gc 慢，是当时的技术没能力做到高性能的全堆回收，比如高性能的并发整理 + 回收集的确定算法。不过分代确实可以加快回收频率，提高能承受的对象分配速率。









##### 标记-复制算法

主要应用于可回收对象多的场景，那么只用复制一小部分（即新生代）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026145018802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)






为了解决标记-清除算法**面对大量可回收对象**时执行效率低的问题，使用 “半区复制”

* 它将可用内存按容量划分为大小相等的两半，每次只使用其中的一半。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

* 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

  

但其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一点。

* 不过新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1∶1的比例来划分新生代的内存空间。

* 更优化的半区复制分代策略
  * 是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。
    * HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。
  * 当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）。
    * 如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象，这些对象便将通过分配担保机制直接进入老年代，这对虚拟机来说就是安全的



##### 标记-清除算法

主要应用于可回收对象少的场景，那么只用删除一小部分（即老年代）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026145035840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)


主要缺点有两个：

* 第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过
  程的执行效率都随对象数量增长而降低；
* 第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作





##### 标记-整理算法

主要用于解决碎片问题，虽然标记-复制也可以，但是需要浪费空间且还要有逃生门，所以只能用于新生代，老生代再没有逃生门，而且老生代大部分都是存活对象，标记-整理只复制一部分比标记-复制全部都复制效率高。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026145049711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)










过程

* 其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。



老年代算法（对比标记-清除）

* 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策：
  * 如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为“Stop The World” 。
  * 但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题（计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。



HotSpot 绝策

* 关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，
* 而关注延迟的 CMS 收集器则是基于标记-清除算法的。
* 还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。

