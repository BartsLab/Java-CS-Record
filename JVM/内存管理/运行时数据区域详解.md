### 运行时数据区域

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026143434131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)




#### 程序计数器

在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。



如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。



此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。



#### 虚拟机栈

与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。

虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。



两类异常状况：

* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。（无限递归即可）；

* 如果Java虚拟机栈容量可以动态扩展 ，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。

  HotSpot虚拟机的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError 异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异常。

  *  模拟方法一：可以采用 Classic 虚拟机，然后在方法内部定义很多 long 型变量，这样来大幅增加局部变量表大小，从而增加栈帧的大小，然后导致虚拟机栈要拓展却没有空间开辟
  *  模拟方法二：对于 32 位操作系统 ，单进程最大内存为 2 GB，同时 jvm 的主要内存占用是 堆 和 方法区（程序计数器占的很小），所以剩下的就是虚拟机栈和本地栈了，那么可以通过 -Xss 把每个虚拟机栈的容量设置到 2M，然后在死循环里不断开辟线程，之后就会 oom





##### 栈帧

* 每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。

* 在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中 。换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。 

* 对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为“当前栈帧”（Current Stack Frame），与这个栈帧所关联的方法被称为“当前方法”（Current Method）。



局部变量表

* 局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放**方法参数**和方法**内部定义的局部变量**。其大小在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了。（补充说明：局部变量不像类变量那样存在“准备阶段”，如果使用的一个局部变量没有赋初始值，无法通过编译与类加载的校验）

  

* 变量槽大小

  * 一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有boolean、byte、char、short、int、float、reference 和returnAddress这8种类型。

    * reference类型表示对一个对象实例的引用，通过这个引用应当做到两件事情，一是从根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引，二是根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。
    * returnAddress类型目前已经很少见了，它是为字节码指令jsr、jsr_w和ret服务的，指向了一条字节码指令的地址，某些很古老的Java虚拟机曾经使用这几条指令来实现异常处理时的跳转，但现在也已经全部改为采用异常表来代替了。

  * 对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。Java语言中明确的64位的数据类型只有long和double两种。

    * 这里把long和double数据类型分割存储的做法，与Java内存模型中“long和double的非原子性协定”，允许把一次long和double数据类型读写分割为两次32位读写的做法有些类似
    * 不过，由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞争和线程安全问题。

    

* 变量槽定位

  * 如果访问的是32位数据类型的变量，索引N就代表了使用第N个变量槽；如果访问的是64位数据类型的变量，则说明会同时使用第N和N+1两个变量槽。
    * 对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机不允许采用任何方式单独访问其中的某一个，《Java虚拟机规范》中明确要求了如果遇到进行这种操作的字节码序列，虚拟机就应该在类加载的校验阶段中抛出异常。



* 变量槽存放顺序

  * 如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数，否则传递的参数从 0 号槽位开始按照参数表顺序存放。

    * 参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。

    

* 变量槽重用

  * 方法体中定义的变量，，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。

  * 不过，这样的设计除了节省栈帧空间以外，还会伴随有少量额外的副作用，例如在某些情况下变量槽的复用会直接影响到系统的垃圾收集行为，因为一个变量槽被 load 后，并不会说是清空该变量槽的内容。

    ```java
    public static void main(String[] args)() {
        {
    		byte[] placeholder = new byte[64 * 1024 * 1024];
    	}
    	System.gc(); // 没有回收上面的 64M 空间
    }
    
    public static void main(String[] args)() {
        {
    		byte[] placeholder = new byte[64 * 1024 * 1024];
    	}
        int a = 0;
    	System.gc(); // 回收了上面的 64M 空间
    }
    ```





操作数栈

* 操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。
* 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。

* 保证
  * Javac编译器的数据流分析工作保证了在方法执行的任何时候，操作数栈的深度都不会超过max_stacks。
  * 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。

* 优化 
  * 两个栈帧出现一部分重叠，让下面栈帧的部分操作数栈，与上面栈帧的部分局部变量表重叠在一起。节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了（因为是把操作都 load 后才调用的 invoke*）



动态连接

* 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
* 字节码中的方法调用指令是以常量池里指向方法的符号引用作为参数，其解析后的直接引用存放在运行时常量池，所以要通过运行时常量池获得直接引用。但如果没有如果没有在类加载时解析的话还会进行解析
  * 符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。
  * 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态分派。



方法返回地址

* 当一个方法开始执行后，只有两种方式退出这个方法。
  * 第一种方式是执行引擎遇到任意一个方法返回的字节码指令的“正常调用完成”，并可以将返回值传递给调用者。
  * 另外一种退出方式是在方法执行的过程中遇到了异常，并且没有搜索到匹配的异常处理器，就会导致方法退出，称为“异常调用完成”，且不会给它的上层调用者提供任何返回值的。
* 恢复上层主调方法的执行状态
  * 正常退出时，栈帧中一般会保存主调方法调用时的PC计数器的值，以这个作为返回地址。
  * 而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。



附加信息

* 《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。
* 一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。









#### 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。



《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。



与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。



#### 堆

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。



从回收内存的角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局，而且到了今天 HotSpot 里面也出现了不采用分代设计的新垃圾收集器，所以不可以再说“Java虚拟机的堆内存分为新生代、老年代、永久代、Eden、Survivor……”。



Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的，对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。



Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。



如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。





#### 方法区

（逻辑区域）

方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。



方法区和 “永久代”两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的工作。这种设计导致了Java应用更容易遇到内存溢出的问题，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念，改用本地内存中实现的元空间（Meta-space）来代替。**相当于永久代的数据被分到了堆和元空间中**，元空间存储类型信息，静态变量和字符串常量池等并入堆中。



《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。



垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。



如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常

* 如果因为字符串常量池这些被移到堆上的方法区部分，其 oom 原因会是 heap space，通过不断String入池模拟

* 如果因为类信息这些在元空间的方法区部分，其 oom 原因会是 metaspace，通过不断生成代理类模拟

  

  



##### 方法区常量池

**Class文件常量池**（只存在于 class 文件中，类加载到内存后存放到方法区的运行时常量池中）

​    Class 文件常量池指的是编译生成的 class 字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种 字面量 和 符号引用，这部分内容 将**在类加载后该常量池将进入方法区的运行时常量池**中存放。

- 字面量，是指字符串字面量和声明为 final 的（基本数据类型）常量值，这些字符串字面量除了类中所有双引号括起来的字符串(包括方法体内的)，还包括所有用到的类名、方法的名字和这些类与方法的字符串描述、字段(成员变量)的名称和描述符；声明为final的常量值指的是成员变量，不包含本地变量，本地变量是属于方法的。这些都在常量池的 UTF-8 表中(逻辑上的划分)；

- 符号引用，就是指指向 UTF-8 表中向这些字面量的引用，包括类和接口的全限定名(包括包路径的完整名)、字段的名称和描述符、方法的名称和描述符。只不过是以一组符号来描述所引用的目标，和内存并无关，所以称为符号引用，直接指向内存中某一地址的引用称为直接引用；

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026143533104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)




**运行时常量池**

存放内容：书上说类文件常量池会在类加载后存放到方法区的运行时常量池中，还会把由符号引用解析出来的直接引用也存储在运行时常量池中。（所以每个栈帧都有指向运行时常量，而且解析也有很多文章说的不全面，主要包括：类加载时的静态解析，还有方法运行时的动态分代）

存放位置：书上没有说，而且网上都是验证的字符串常量池，但根据书上是说的“在JDK1.7 字符串常量池被从方法区拿到了堆中”, 这里没有提到运行时常量池，只说了字符串常量池被单独拿到堆，那就说明运行时常量池剩下的东西还在永久代。再有后面说的 “在JDK1.8 hotspot移除了永久代用元空间取而代之“，所以运行时常量池剩下的东西应该在元空间。

个人理解：书上始终没有说明运行时常量池的位置，都是说的方法区的运行时常量池，可能因为这只是不同虚拟机实现的区别，没有必要区分那么细。

看了很多文章后这个比较靠谱：所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息，**每个class都有一个**运行时常量池，主要存放，编译后的代码, class文件元信息描述，类文件常量池，引用类型数据。



**字符串常量池**（该部分肯定在堆上，是 jdk7 时从运行时常量池中分出去的）

​    字符串常量池是**全局**的，JVM 中独此一份，因此也称为全局字符串常量池。其存的是String对象的**引用值**而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。

​	在HotSpot VM里实现的 string pool 功能的是一个 StringTable 类，它是一个哈希表，key 是字符串的字面量，value 是驻留字符串（也就是我们常说的用双引号括起来的字符串）的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份



​	对于CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info和 C0NSTANT_Double_info 里面也包含它们所表示的常量值，所以可以直接被解析。

​	但是对于CONSTANT_String_info 和 CONSTANT_Class_info 都是一个指向 CONSTANT_UTF8_info 的 index 即符号引用，会在解析阶段后成为直接引用。其中 String_info 是lazy resolve的， 在 ldc 指令被第一次执行到的时候才会resolve，解析的过程是去 StringTable 查找，因为 StringTable 是哈希表，key 是 String的字面量，所以如果没有被解析的话，即在堆上开辟一块空间实例化该字符串，然后把引用保存到 StringTable，再把 String_info 的直接地址保存才运行时常量池。





常量拼接实例：

* ```java
  String str1 = "str";
  String str2 = "ing";
  
  String str3 = "str" + "ing"; // 常量拼接，即 str3 = "string"
  String str4 = str1 + str2;   // 变量拼接
  System.out.println(str3 == str4); // false
  
  String str5 = "string";
  System.out.println(str3 == str5); // true
  ```

* ```java
  public static final String A = "ab"; // 常量A
   public static final String B = "cd"; // 常量B
  
   public static void main(String[] args) {
       String s = A + B;  // 将 static final 的变量 直接赋值后 拼接
       String t = "abcd";   
       System.out.println(s == t); // true。
       // 因为A和B都是常量，值是固定的，因此s的值也是固定的，它在类被编译时就已经确定了，即 String s="ab"+"cd" ="abcd"
   } 
  
  //=======================================================================================================
  
   public static final String A;  // 常量A
   public static final String B;  // 常量B
   static {   
       A = "ab";   
       B = "cd";   
   }   
  
   public static void main(String[] args) {     
       String s = A + B; // 将 static final 的变量 在静态代码块赋值后 拼接
       String t = "abcd";   
       System.out.println(s == t); // false。
       // A和B虽然被定义为常量，但是它们都没有马上被赋值。在运算出s的值之前，他们何时被赋值，以及被赋予什么样的值，都是个变数。
       // 因此A和B在被赋值之前，性质类似于一个变量。那么s就不能在编译期被确定，而只能在运行时被创建了。
   } 
  ```



而且对于 String 类的 `intern()` 方法还可在运行期间把字符串放到字符串常量池中。但是注意一下

* JDK 6 中的，字符串常量池是在 PermGen space（永久代，其并非是堆，所以入池后会复制到永久代，然后返回永久代种该对象的引用）

* 而 JDK 7 中的，字符串常量池是在堆中，所以在入池之后，如果池中没有的话，那么直接把这个堆中的引用保存到 stringTable，所以如果以前没入过池的话，那么 s.intern() = s

* ```java
  public static void main(String[] args) {
  	String str1 = new StringBuilder("计算机").append("软件").toString();
  	System.out.println(str1.intern() == str1); // JDK 6 false ；JDK 7 true
      
      // 说明一下 “java” 在 JDK 某些类初始化的时候就入过池了
  	String str2 = new StringBuilder("ja").append("va").toString();
  	System.out.println(str2.intern() == str2); // JDK 6 false ; JDK 7 false
  }
  ```

  



##### 方法区垃圾回收

* 这里指的元空间的垃圾回收，字符串常量池和静态变量这种在堆上的方法去部分，就由堆决定是否回收



有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载）。

方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。



JDK 8 提供的一些元空间的参数

* -XX：MaxMetaspaceSize：设置元空间最大值，默认是 -1，即不限制，或者说只受限于本地内存大小。
* -XX：MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过-XX：MaxMetaspaceSize（如果设置了的话）的情况下，适当提高该值，以提高回收效率。
* -XX：MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX：Max-MetaspaceFreeRatio，用于控制最大的元空间剩余容量的百分比。



方法区（元空间）的垃圾收集主要回收两部分内容：**废弃的常量**和**不再使用的类型**。

* 回收废弃常量 （应该是指的运行时常量池里常量的回收，而其常量主要来自 class 文件的常量池）
  * 与回收 Java 堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串字面量“java”曾经进入运行时常量池中，
    * 但是当前系统又没有任何一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，
    * 且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java” 字面量就将会被系统清理出运行时常量池。
  * 常量池中其他类（接口）、方法、字段的符号引用也与此类似, 需要同时满足 没有其它地方 import 并且 没有其他地方使用该符号引用
* 回收不再使用的类型
  * 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
    * 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。

    * 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。

    * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  * Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。
  * 还可以使用-verbose：class以及-XX：+TraceClass-Loading、-XX：+TraceClassUnLoading查看类加载和卸载信息



#### 直接内存

直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。



在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。



显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。

* 可通过-XX：MaxDirectMemorySize参数来指定，如果不去指定，则默认与Java堆最大值（由-Xmx指定）一致

* 如果要模拟，虽然使用 DirectByteBuffer 分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe::allocateMemory()。

* 由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory（典型的间接使用就是NIO），那就可以考虑重点检查一下直接内存方面的原因了。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026143507845.png#pic_center)
