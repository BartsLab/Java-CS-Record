#### 加载过程

阶段

* 一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。

* 其中验证、准备、解析三个部分统称为连接（Linking）。

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026152313757.png#pic_center)




顺序

* 加载、验证、准备、初始化和卸载这五个阶段的开始顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。
* 这些阶段通常都是互相交叉地混合进行的，会在一个阶段执行的过程中调用、激活另一个阶段。





##### 加载

完成以下三件事情

* 通过一个类的全限定名来获取定义此类的二进制字节流，比如从文件、压缩包、网络等。（能实现从任意来源获取，是因为 jvm 允许自定类加载器）
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
* 在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。





##### 验证

* 如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 -Xverify：none参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间



文件格式验证

* 第一阶段要验证字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析，只有通过了验证这段字节流才被允许进入方法区中进行存储。
* 这阶段的验证是基于二进制字节流进行的，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。



元数据验证

* 第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java语言规范》的要求。



字节码验证

* 第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流分析和控制流分析，确定类的方法体（Class文件中的Code属性）是合法、符合逻辑。
* 在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性，这项属性描述了方法体所有的基本块（Basic Block，指按照控制流拆分的代码块）**开始时本地变量表和操作栈应有的状态**，在字节码验证期间，Java虚拟机就不需要根据程序推导这些状态的合法性，只需要检查StackMapTable属性中的记录是否合法即可



符号引用验证

* 最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。

  

  

##### 准备

准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量**初始值**的阶段。

* “通常情况”下,初始值是数据类型的零值

  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026152328403.png#pic_center)


* 如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值

从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域，在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中。





##### 解析

解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。（注意：这种是静态解析，只解析只有一个确定版本的符号引用）

* 符号引用（Symbolic References）
  * 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
  * 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。
* 直接引用（Direct References）：
  * 直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。
  * 直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同





执行时机

* 《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行下面这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。

  * 常量（符号引用为 String、Class）：ldc、ldc_w、ldc2_w
  * 类（符号引用为 Class）：new、anewarray、multianewarray、instanceof、checkcast

  * 字段（符号引用为 Fieldref）：getfield、putfield、getstatic、putstatic

  * 方法（有 5 条 invoke* 指令）：invokevirtual、invoke-special、invokestatic、invokeinterface、invokedynamic

  



符号引用为 Class 类加载时解析

* 假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：
  * 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。
  * 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似“[Ljava/lang/Integer”的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象。
    * 个人观点：这个说法和前面加载时机那里就是矛盾的，而且测试之后，对于数组实例来说，其类型是由jvm在运行期动态生成（比如 Type[] 其生成的类型就是 [LType ）的，不会导致元素类型初始化
  * 如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常。



符号引用为 String 懒解析

* 对于CONSTANT_String_info 和 CONSTANT_Class_info 一样，其数据结构里都是一个指向 CONSTANT_UTF8_info 的 index（即符号引用），会在解析阶段后成为直接引用。
* 其中 String_info 是lazy resolve的， 在 ldc 指令被第一次执行到的时候才会resolve，解析的过程是去 StringTable 查找，因为 StringTable 是哈希表，key 是 String的字面量，所以如果没有被解析的话，即在堆上开辟一块空间实例化该字符串，然后把引用保存到 StringTable，再把 String_info 的直接地址保存才运行时常量池。



符号引用为 Filedref 类加载时解析

* 要解析一个未被解析过的字段符号引用，首先将会对其 Filedref 中 class_index 索引的 CONSTANT_Class_info 符号引用进行解析，也就是字段所属的类或接口的符号引用。

  如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。

  如果解析成功完成，那把这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：

  * 如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  * 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  * 否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
  * 否则，查找失败，抛出java.lang.NoSuchFieldError异常。如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

  如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError 异常。但如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，虽然按照解析规则仍是可以确定唯一的访问字段，不过Javac编译器就可能直接拒绝其编译为Class文件。



方法执行指令要分为三类，只有 invokespecial 和 invokestatic 是类加载时解析，因为方法的多态性，其他三种都是运行时解析，在方法调用部分我们讨论。





##### 初始化

* 初始化阶段就是执行类构造器\<clinit>()方法的过程。

* 自动生成

  * \<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。接口中虽然不能使用静态语句块，但接口与类一样都会生成\<clinit>()方法，如果接口有定义属性（肯定是 public static final），那么接口的 \<clinit>() 也会执行赋值操作。

  * \<clinit>() 是编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

    ```java
    public class Test {
        static {
            i = 0; // 给变量赋值可以正常编译通过
            System.out.print(i); // 这句编译器会提示“非法向前引用”
        }
        static int i = 1;
    }
    ```

  * \<clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器也可以不为这个类生成\<clinit>()方法

  

* 和父类\<clinit>() 执行顺序

  * \<clinit>()方法与类的构造函数（即在虚拟机视角中的实例构造器\<init>()方法）不同，它不需要显式地调用父类构造器，Java虚拟机会保证在子类的\<clinit>()方法执行前，父类的\<clinit>()方法已经执行完毕。因此在Java虚拟机中第一个被执行的\<clinit>()方法的类型肯定是java.lang.Object。

    ```java
    static class Parent {
        public static int A = 1;
        static {
        	A = 2;
        }
    }
    static class Sub extends Parent {
    	public static int B = A;
    }
    
    public static void main(String[] args) {
    	System.out.println(Sub.B); // B的值将会是2而不是1
    }
    ```

  * 接口与类不同，执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法，接口的实现类在初始化时也不会先执行接口的\<clinit>()方法，只有在使用到接口定义的常量或者方法时的时才会初始化（因为 getFeild 或者 invokeInterface 指令，会触发类加载，即根据根据其操作数 Filedref 或者 InterfaceMethodref 找到 NameAndType 中的 class_index 去加载这个类（接口））。



* 线程安全

  * Java虚拟机必须保证一个类的\<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕\<clinit>()方法。

  * 如果在一个类的\<clinit>()方法中有耗时很长的操作，那就可能造成多个线程阻塞（比如要 new 该类实例的，或者要使用该类静态方法或者属性的） ，在实际应用中这种阻塞往往是很隐蔽的。

    ```java
    static class DeadLoopClass {
        static {
            // 如果不加上这个if语句，编译器将提示“Initializer does not complete normally”并拒绝编译
            if (true) {
                System.out.println(Thread.currentThread() + "init DeadLoopClass");
                while (true) {
                }
            }
        }
    }
    public static void main(String[] args) {
        Runnable script = () -> new DeadLoopClass();
        Thread thread1 = new Thread(script);
        Thread thread2 = new Thread(script);
        thread1.start();
        thread2.start();
    }
    
    // 一个线程会一直阻塞等待另一个线程执行 <clinit>() 完毕
    ```
