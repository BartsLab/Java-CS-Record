### 编译与优化

#### 前端编译器Javac

从Javac代码的总体结构来看，编译过程大致可以分为1个准备过程和3个处理过程，它们分别如下所示。

* 准备过程：初始化插入式注解处理器。

* 解析与填充符号表过程，包括：
  * 词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
  * 填充符号表。产生符号地址和符号信息。

* 插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段

* 分析与字节码生成过程，包括：

  * 标注检查。对语法的静态信息进行检查。
  * 数据流及控制流分析。对程序动态运行过程进行检查。
  * 解语法糖。将简化代码编写的语法糖还原为原有的形式。
  * 字节码生成。将前面各个步骤所生成的信息转化成字节码。



后面3个处理过程里，执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转回到之前的解析、填充符号表的过程中重新处理这些新符号.

从总体来看，三者之间的关系与交互顺序如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026152708177.png#pic_center)




入口是 com.sun.tools.javac.main.JavaCompiler类，代码逻辑集中在这个类的 compile() 和 compile2() 方法里

其中主体代码如图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201026152721737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)








#### 语法糖

##### 泛型

类型擦除式泛型

* 对方法的Code属性中的泛型字节码进行擦除，即在 new 一个泛型对象时，对类型参数进行擦除。（实际上反编译还能看到方法体里有泛型，是因为LocalVariableTypeTable，而这个和 LocalVariableTable 一样，都是为了调试方便，可以通过增加 javac 的命令行 -g:none 关掉）。

* 如果类或方法定义了泛型 T，那么会在 class 文件的Signature属性中，记录包含泛型信息的方法或者类的签名（反编译可以看到方法或者类的定义上有泛型，也是因为该属性，但 Signature 属性仅限于获取泛型的签名，调用方法时的 Methodref  仍然不包含泛型信息）。

  * 如果父类的泛型是 T，子类对泛型 T 进行了定义，那么可以通过 Class#getGenericInterfaces() 或者 Class#getGenericSuperclass() 得到 ParameterizedType，然后通过getActualTypeArguments() 就可以获得子类定义的泛型信息。
  * 如果当前类定义的泛型就是 T ，那么是没法获得当前类的泛型信息的。

  ```java
  static class A<T1,T2>{}
  static class B extends A<String,Integer>{}
  
  public static void main(String[] args) {
      Type superclass = B.class.getGenericSuperclass();
      if(superclass instanceof ParameterizedType){
          Type[] actualTypeArguments = ((ParameterizedType)superclass).getActualTypeArguments();
          for(Type t: actualTypeArguments){
              System.out.println(t.getTypeName());
          }
      }
  }
  
  // java.lang.String
  // java.lang.Integer
  ```

  

类型擦除坏处

* 直接导致无法支持原始类型，因为擦除之后类型都是 Object，那么如果 \<int>、\<double>，这种泛型在擦除后，其里面的元素无法转换为 Object，所以 java 的解决方案就是“既然没法转换那就索性别支持原生类型的泛型了吧”，所以就又提供了原始类型的自动装拆箱，这也就是java泛型慢和开销大的一个重要原因

* 无法获得 new 该泛型对象时传递的类型参数（即运行期无法取到泛型类）

  ```java
  public class TypeErasureGenerics<E> {
      public void doSomething(Object item) {
          if (item instanceof E) { // 不合法，无法对泛型进行实例判断
          }
          E newItem = new E(); // 不合法，无法使用泛型创建对象
          E[] itemArray = new E[10]; // 不合法，无法使用泛型创建数组
      }
  }
  ```

  * 解决办法，直接在方法参数里传递 Class 对象，或者通过 T 的对象 getClass

* 带来了一些模棱两可的模糊状况（重载遇上泛型）

  * 参数只是泛型的类型参数不同，但是返回值相同（不能编译）

    ```java
    public class GenericTypes {
        public static void method(List<String> list) {
            System.out.println("invoke method(List<String> list)");
        }
        public static void method(List<Integer> list) {
            System.out.println("invoke method(List<Integer> list)");
        }
    }
    
    // 不能被编译的，因为参数List<Integer>和List<String>编译之后都被擦除了，变成了同一种的裸类型List，
    // 类型擦除导致这两个方法的特征签名变得一模一样。
    ```

  * 参数只是泛型的类型参数不同，且是返回值不同（可以编译，但与之前的重载规定的只看特征签名，不看返回值矛盾）

    ```java
    public class GenericTypes {
        public static String method(List<String> list) {
            System.out.println("invoke method(List<String> list)");
            return "";
        }
        public static int method(List<Integer> list) {
            System.out.println("invoke method(List<Integer> list)");
            return 1;
        }
        
        public static void main(String[] args) {
            method(new ArrayList<String>());
            method(new ArrayList<Integer>());
        }
    }
    
    // invoke method(List<String> list)
    // invoke method(List<Integer> list)
    ```



##### 其余常用语法糖

自动装箱拆箱：自动调用包装类的 .valueOf() 方法

* 补充：遇到 算数运算符（即 + - * / 这类），会自动拆箱
* 遇到 ==，如果有一边是基本类型，那么都会拆箱成基本类型
* 遇到 equals，都是装箱后比较

遍历循环：必须实现 Iterator 接口，自动调用的 iterator#hasNext 和 iterator#next 进行的遍历

变长数组：解语法糖为 new Type[] { ... }



案例

* javac 编译前

  ```java
  public static void main(String[] args) {
  	List<Integer> list = Arrays.asList(1, 2, 3, 4);
  	int sum = 0;
  	for (int i : list) {
  		sum += i;
  	}
  	System.out.println(sum);
  }
  ```

  

* javac 编译后

  ```java
  public static void main(String[] args) {
      List list = Arrays.asList( new Integer[] {
              Integer.valueOf(1),
              Integer.valueOf(2),
              Integer.valueOf(3),
              Integer.valueOf(4) });
      int sum = 0;
      for (Iterator localIterator = list.iterator(); localIterator.hasNext(); ) {
          int i = ((Integer)localIterator.next()).intValue();
          sum += i;
      }
      System.out.println(sum);
  }
  ```

  





#### 后端编译器优化

* 主要指的运行时的即时编译器



##### 方法内联

最重要的优化技术之一：方法内联。



优点

* 一是去除方法调用的成本（如查找方法版本、建立栈帧等）
* 二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。



实现

* 内联与虚方法之间会产生“矛盾”。大多数的Java方法都无法进行内联，只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析，其他的Java方法调用都必须在运行时进行方法接收者的多态选择，而 java 的面向对象特性又鼓励使用虚方法。
* 解决虚方法的内联问题。引入了一种名为类型继承关系分析，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。
  * 如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；
  * 如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（Guarded Inlining）
  * 不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。
* 假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。
  * 工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存（Monomorphic InlineCache）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。
  * 但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存（Megamorphic Inline Cache），其开销相当于真正查找虚方法表来进行方法分派。



所以说，在多数情况下Java虚拟机进行的方法内联都是一种激进优化。



##### 逃逸分析

最前沿的优化技术之一：逃逸分析。

与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。



原理：分析对象动态作用域。当一个对象在方法里面被定义后，它可能被外部方法所引用

* 如作为调用参数传递到其他方法中，这种称为方法逃逸；
* 如被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；
* 从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。



如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：

* 栈上分配
  * 如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。
  * 在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。
  * 栈上分配可以支持方法逃逸，但不能支持线程逃逸。
* 标量替换
  * 标量：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。
  * 聚合量：如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java中的对象就是典型的聚合量。
  * 如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。
  * 假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。
  * 标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。
* 同步消除
  * 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。



尚未足够成熟

* 原因主要是逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗。
* 如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象，那这些运行期耗用的时间就白白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成分析。





##### 公共子表达式消除

语言无关的经典优化技术之一：公共子表达式消除。



含义

* 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。
* 如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）





##### 数组边界检查消除

语言相关的经典优化技术之一：数组边界检查消除。



含义

* Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。在Java语言中访问数组元素的时候系统将会自动进行上下界的范围检查，即i必须满足“i>=0&&i<array.length”的访问条件，否则将抛出一个运行时异常。
* 这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。



实现

* 单个索引访问，编译期根据数据流分析确定数组长度，并判断索引是否超过 lenth
* 循环遍历，通过数据流分析就可以判定循环变量的取值范围永远在区间[0，array.length)之内
* 还有一种避开的处理思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。即虚拟机会注册一个Segment Fault信号的异常处理器，但进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。所以会根据运行期收集到的性能监控信息自动选择最合适的方案。
