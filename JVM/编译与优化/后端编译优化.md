#### 后端编译器优化

* 主要指的运行时的即时编译器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201027095051449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)![在这里插入图片描述](https://img-blog.csdnimg.cn/20201027095146512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkzNDYwNw==,size_16,color_FFFFFF,t_70#pic_center)



##### 方法内联

最重要的优化技术之一：方法内联。



优点

* 一是去除方法调用的成本（如查找方法版本、建立栈帧等）
* 二是为其他优化建立良好的基础。方法内联膨胀之后可以便于在更大范围上进行后续的优化手段，可以获取更好的优化效果。



实现

* 内联与虚方法之间会产生“矛盾”。大多数的Java方法都无法进行内联，只有使用invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析，其他的Java方法调用都必须在运行时进行方法接收者的多态选择，而 java 的面向对象特性又鼓励使用虚方法。
* 解决虚方法的内联问题。引入了一种名为类型继承关系分析，这是整个应用程序范围内的类型分析技术，用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等信息。
  * 如果是非虚方法，那么直接进行内联就可以了，这种的内联是有百分百安全保障的；
  * 如果遇到虚方法，则会向CHA查询此方法在当前程序状态下是否真的有多个目标版本可供选择，如果查询到只有一个版本，那就可以假设“应用程序的全貌就是现在运行的这个样子”来进行内联，这种内联被称为守护内联（Guarded Inlining）
  * 不过由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于激进预测性优化，必须预留好“逃生门”，即当假设条件不成立时的“退路”（Slow Path）。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已经编译的代码，退回到解释状态进行执行，或者重新进行编译。
* 假如向CHA查询出来的结果是该方法确实有多个版本的目标方法可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用是真正发生了的，但是比起直接查虚方法表还是要快一些。
  * 工作原理大致为：在未发生方法调用之前，内联缓存状态为空，当第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者的版本。如果以后进来的每次调用的方法接收者版本都是一样的，那么这时它就是一种单态内联缓存（Monomorphic InlineCache）。通过该缓存来调用，比用不内联的非虚方法调用，仅多了一次类型判断的开销而已。
  * 但如果真的出现方法接收者不一致的情况，就说明程序用到了虚方法的多态特性，这时候会退化成超多态内联缓存（Megamorphic Inline Cache），其开销相当于真正查找虚方法表来进行方法分派。



所以说，在多数情况下Java虚拟机进行的方法内联都是一种激进优化。



##### 逃逸分析

最前沿的优化技术之一：逃逸分析。

与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。



原理：分析对象动态作用域。当一个对象在方法里面被定义后，它可能被外部方法所引用

* 如作为调用参数传递到其他方法中，这种称为方法逃逸；
* 如被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；
* 从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。



如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化，如：

* 栈上分配
  * 如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。
  * 在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。
  * 栈上分配可以支持方法逃逸，但不能支持线程逃逸。
* 标量替换
  * 标量：若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。
  * 聚合量：如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java中的对象就是典型的聚合量。
  * 如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。
  * 假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么程序真正执行的时候将可能不去创建这个对象，而改为直接创建它的若干个被这个方法使用的成员变量来代替。将对象拆分后，除了可以让对象的成员变量在栈上（栈上存储的数据，很大机会被虚拟机分配至物理机器的高速寄存器中存储）分配和读写之外，还可以为后续进一步的优化手段创建条件。
  * 标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。
* 同步消除
  * 线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以安全地消除掉。



尚未足够成熟

* 原因主要是逃逸分析的计算成本非常高，甚至不能保证逃逸分析带来的性能收益会高于它的消耗。
* 如果逃逸分析完毕后发现几乎找不到几个不逃逸的对象，那这些运行期耗用的时间就白白浪费了，所以目前虚拟机只能采用不那么准确，但时间压力相对较小的算法来完成分析。





##### 公共子表达式消除

语言无关的经典优化技术之一：公共子表达式消除。



含义

* 如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。
* 如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）





##### 数组边界检查消除

语言相关的经典优化技术之一：数组边界检查消除。



含义

* Java语言是一门动态安全的语言，对数组的读写访问也不像C、C++那样实质上就是裸指针操作。在Java语言中访问数组元素的时候系统将会自动进行上下界的范围检查，即i必须满足“i>=0&&i<array.length”的访问条件，否则将抛出一个运行时异常。
* 这对软件开发者来说是一件很友好的事情，即使程序员没有专门编写防御代码，也能够避免大多数的溢出攻击。但是对于虚拟机的执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。



实现

* 单个索引访问，编译期根据数据流分析确定数组长度，并判断索引是否超过 lenth
* 循环遍历，通过数据流分析就可以判定循环变量的取值范围永远在区间[0，array.length)之内
* 还有一种避开的处理思路——隐式异常处理，Java中空指针检查和算术运算中除数为零的检查都采用了这种方案。即虚拟机会注册一个Segment Fault信号的异常处理器，但进入异常处理器的过程涉及进程从用户态转到内核态中处理的过程，结束后会再回到用户态，速度远比一次判空检查要慢得多。所以会根据运行期收集到的性能监控信息自动选择最合适的方案。
